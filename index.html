<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jazz Piano Voicings</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #f4f4f4;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #d4af37, #ff6b6b, #a8c8ec);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .mode-toggle {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            gap: 1rem;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #a8c8ec;
            color: #f4f4f4;
            padding: 1rem 2rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            backdrop-filter: blur(10px);
        }

        .mode-btn.active {
            background: #a8c8ec;
            color: #1a1a2e;
            box-shadow: 0 4px 20px rgba(168, 200, 236, 0.3);
        }

        .mode-btn:hover {
            transform: translateY(-2px);
        }

        .mode-section {
            display: none;
        }

        .mode-section.active {
            display: block;
        }

        /* Browse Mode Styles */
        .chord-type {
            margin-bottom: 3rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 2rem;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .chord-type h2 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: #d4af37;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .voicing-table {
            display: grid;
            gap: 1.5rem;
        }

        .scale-row {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.5rem;
            border-left: 4px solid #a8c8ec;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .scale-row-content {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .scale-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #a8c8ec;
            margin-bottom: 0.5rem;
            text-transform: capitalize;
        }

        .voicing-grid {
            display: grid;
            gap: 1rem;
            width: 100%;
            overflow: hidden;
            padding: 2px 1rem;
        }

        .voicing-cell {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            border: 2px solid #a8c8ec;
            transition: all 0.3s ease;
            min-height: 100px;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            cursor: pointer;
        }

        .voicing-cell:hover {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
            transform: translateY(-1px) scale(1.01);
        }

        .voicing-cell.selected {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
        }

        .chord-notes {
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            line-height: 1.4;
            color: #f4f4f4;
            white-space: pre-line;
            font-weight: bold;
        }

        .chord-notes .top-note {
            color: #d4af37;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(212, 175, 55, 0.3);
        }

        .empty-cell {
            opacity: 0.3;
            cursor: not-allowed;
        }


        /* Progression Creator Styles */
        .progression-creator {
            display: grid;
            grid-template-columns: minmax(320px, 350px) 1fr;
            gap: 1.5rem;
            height: 75vh;
            max-width: 100%;
            overflow: hidden;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .control-group {
            margin-bottom: 2rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #ffd700;
            font-weight: bold;
        }

        .control-group select,
        .control-group input {
            width: 100%;
            padding: 0.8rem;
            border: none;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #f4f4f4;
            font-size: 1rem;
        }

        .control-group select option {
            background: #1a1a2e;
            color: #f4f4f4;
        }

        .chord-bank {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 0.75rem;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chord-bank h3 {
            color: #a8c8ec;
            margin-bottom: 0.75rem;
            text-align: center;
            font-size: 1.1rem;
        }

        .root-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.25rem;
            margin-bottom: 0.5rem;
            flex: 1;
            overflow: hidden;
            align-content: start;
            padding: 2px;
        }

        .root-option {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #a8c8ec;
            color: #f4f4f4;
            padding: 0.3rem;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 35px;
        }

        .root-option:hover {
            background: rgba(168, 200, 236, 0.2);
            transform: scale(1.02);
        }

        .root-option.selected {
            background: rgba(168, 200, 236, 0.3);
            border-color: #d4af37;
        }

        .chord-type-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .chord-type-option {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #a8c8ec;
            color: #f4f4f4;
            padding: 0.6rem;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            position: relative;
        }

        .chord-type-option:hover {
            background: rgba(168, 200, 236, 0.2);
            transform: scale(1.02);
        }

        .chord-type-option:hover::after {
            content: "Double-click to add";
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ffd700;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        .back-to-roots {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid #ff6b6b;
            color: #f4f4f4;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-to-roots:hover {
            background: rgba(255, 107, 107, 0.3);
            transform: translateY(-1px);
        }

        .chord-type-menu h4 {
            color: #ffd700;
            margin-bottom: 1rem;
        }

        .root-selection h4 {
            color: #4ecdc4;
            margin-bottom: 1rem;
        }

        .note-headers {
            display: grid;
            gap: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            padding: 0 1rem;
            position: relative;
        }

        .note-header {
            text-align: center;
            font-weight: bold;
            color: #d4af37;
            font-size: 1.1rem;
            position: relative;
        }

        .chord-type {
            position: relative;
        }

        .progression-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            max-width: 100%;
            overflow-x: auto;
        }

        .progression-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .progression-header h2 {
            color: #d4af37;
            margin: 0;
        }

        .progression-controls {
            display: flex;
            gap: 0.8rem;
        }

        .save-btn, .load-btn, .clear-btn {
            background: rgba(168, 200, 236, 0.2);
            border: 2px solid #a8c8ec;
            color: #a8c8ec;
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .clear-btn {
            background: rgba(255, 107, 107, 0.2);
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .save-btn:hover, .load-btn:hover {
            background: rgba(168, 200, 236, 0.4);
            transform: translateY(-2px);
        }

        .clear-btn:hover {
            background: rgba(255, 107, 107, 0.4);
            transform: translateY(-2px);
        }

        .progression-container {
            min-height: 400px;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: flex-start;
            justify-content: center;
        }

        .chord-slot {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #a8c8ec;
            border-radius: 12px;
            padding: 1.2rem;
            min-width: 180px;
            max-width: 220px;
            height: 580px;
            transition: all 0.3s ease;
            flex-shrink: 1;
            display: flex;
            flex-direction: column;
        }

        .chord-slot:hover {
            border-color: #d4af37;
        }

        .chord-slot.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .chord-slot.drag-over {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .drag-handle {
            color: #8B7D6B;
            cursor: grab;
            font-weight: bold;
            margin-right: 8px;
            user-select: none;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drop-zone {
            width: 4px;
            height: 100%;
            background: #ffd700;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s ease;
            margin: 0 8px;
        }

        .drop-zone.active {
            opacity: 1;
        }

        .voice-leading-connector {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            margin: 0 0.5rem;
            align-self: flex-start;
            padding-top: 15.05rem;
            justify-content: flex-start;
        }

        .voice-movement {
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            height: 2rem;
            margin: 0.2rem 0;
        }

        .voice-movement.common {
            background: rgba(76, 175, 80, 0.6);
            border-color: #4CAF50;
            color: white;
        }

        .voice-movement.step {
            background: rgba(33, 150, 243, 0.6);
            border-color: #2196F3;
            color: white;
        }

        .voice-movement.leap {
            background: rgba(255, 152, 0, 0.6);
            border-color: #FF9800;
            color: white;
        }

        .chord-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.2rem;
        }

        .chord-symbol {
            font-size: 1.8rem;
            font-weight: bold;
            color: #d4af37;
        }

        .remove-chord {
            background: #ff6b6b;
            border: none;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .voicing-selector {
            margin-bottom: 1rem;
        }

        .voicing-navigation {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .top-note-selector {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .top-note-label {
            color: #d4af37;
            font-size: 0.9rem;
            font-weight: bold;
            text-align: center;
        }

        .top-note-dropdown {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid #d4af37;
            border-radius: 6px;
            background: rgba(212, 175, 55, 0.1);
            color: #d4af37;
            font-weight: bold;
            font-size: 1.1rem;
            text-align: center;
        }

        .top-note-dropdown option {
            background: #1a1a2e;
            color: #d4af37;
        }

        .nav-arrow {
            background: rgba(168, 200, 236, 0.2);
            border: 2px solid #a8c8ec;
            color: #a8c8ec;
            padding: 0.8rem;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-arrow:hover {
            background: rgba(168, 200, 236, 0.4);
            transform: scale(1.1);
        }

        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        .voicing-navigation-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: center;
        }

        .voicing-counter {
            color: #f4f4f4;
            font-size: 0.8rem;
            min-width: 50px;
            text-align: center;
        }


        .selected-voicing {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.2rem;
            font-family: 'Courier New', monospace;
            font-size: 1.4rem;
            line-height: 1.5;
            text-align: center;
            white-space: pre-line;
            font-weight: bold;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 200px;
        }

        .voicing-with-positions {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .voice-position {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.4rem 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin: 0.2rem 0;
            height: 2rem;
        }

        .voice-note {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .voice-position.top-note .voice-note {
            color: #d4af37;
        }

        .voicing-scale-name {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
            font-weight: normal;
            font-family: 'Georgia', serif;
            margin-top: 1rem;
            font-style: italic;
            height: 2.5rem;
            overflow: hidden;
            line-height: 1.2;
            display: flex;
            align-items: flex-end;
        }

        .empty-progression {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 1.2rem;
            margin-top: 3rem;
        }

        .top-note-line {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .top-note-line h3 {
            color: #ffd700;
            margin-bottom: 1rem;
        }

        .top-note-sequence {
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            color: #4ecdc4;
            letter-spacing: 2px;
        }

        @media (max-width: 1200px) {
            .progression-creator {
                grid-template-columns: minmax(260px, 300px) 1fr;
                gap: 1rem;
            }
        }

        @media (max-width: 768px) {
            .progression-creator {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .controls-panel {
                padding: 1rem;
            }
            
            .progression-area {
                padding: 1rem;
            }
            
            .chord-slot {
                min-width: 160px;
                max-width: 200px;
                height: 540px;
            }
        }

        /* Progressions Library Styles */
        .progressions-library {
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .progression-selector {
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .progression-selector label {
            font-weight: bold;
            color: #8B7D6B;
        }

        .progression-selector select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            color: #E8E3D3;
            font-size: 1rem;
            min-width: 150px;
        }

        .library-layout {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 2rem;
            margin-top: 2rem;
        }

        .top-note-line-nav {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(212, 175, 55, 0.2);
            height: fit-content;
            position: sticky;
            top: 1rem;
        }

        .top-note-line-nav h3 {
            color: #d4af37;
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            text-align: center;
        }

        .nav-controls {
            margin-bottom: 1rem;
        }

        .search-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 6px;
            padding: 0.6rem 1rem;
            color: #E8E3D3;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
        }

        .search-input::placeholder {
            color: #8B7D6B;
        }

        .sort-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sort-label {
            font-size: 0.8rem;
            color: #F5F5DC;
            opacity: 0.8;
        }

        .sort-switch {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 2px;
            position: relative;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }

        .sort-switch input[type="radio"] {
            display: none;
        }

        .sort-switch label {
            flex: 1;
            padding: 0.4rem 0.8rem;
            font-size: 0.7rem;
            color: #F5F5DC;
            text-align: center;
            cursor: pointer;
            border-radius: 18px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
            opacity: 0.7;
        }

        .sort-switch input[type="radio"]:checked + label {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.8), rgba(212, 175, 55, 0.6));
            color: #1a1a1a;
            font-weight: 600;
            opacity: 1;
            box-shadow: 0 2px 4px rgba(212, 175, 55, 0.3);
        }

        .sort-switch label:hover {
            opacity: 1;
        }

        .nav-btn {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 6px;
            padding: 0.6rem 1rem;
            color: #E8E3D3;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
        }

        .nav-btn.active {
            background: rgba(212, 175, 55, 0.2);
            border-color: #d4af37;
            color: #d4af37;
            font-weight: bold;
        }

        .top-note-line-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.1);
        }

        .top-note-line-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .top-note-line-item:last-child {
            border-bottom: none;
        }

        .top-note-line-item:hover {
            background: rgba(212, 175, 55, 0.1);
            border-color: #d4af37;
        }

        .top-note-line-item.active {
            background: rgba(212, 175, 55, 0.15);
            border-color: #d4af37;
        }

        .top-note-line-name {
            font-weight: bold;
            color: #d4af37;
            font-family: 'Courier New', monospace;
        }

        .top-note-line-count {
            font-size: 0.8rem;
            color: #A0A0A0;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
        }

        .top-note-line-browser {
            min-height: 500px;
        }

        .top-note-line-browser h3 {
            color: #d4af37;
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
        }

        @media (max-width: 1024px) {
            .library-layout {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .top-note-line-nav {
                position: static;
            }
            
            .top-note-line-list {
                max-height: 200px;
            }
        }

        .top-note-line-group {
            margin-bottom: 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }

        .top-note-line-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.3);
        }

        .top-note-line-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #d4af37;
        }

        .top-note-line-description {
            color: #A0A0A0;
            font-size: 0.9rem;
        }

        .progression-variations {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1rem;
        }

        .progression-variation {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 8px;
            padding: 1rem;
            transition: all 0.3s ease;
        }

        .progression-variation:hover {
            border-color: #d4af37;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.2);
        }

        .progression-actions {
            display: flex;
            justify-content: center;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 10;
        }

        .save-progression-btn {
            background: linear-gradient(135deg, #d4af37, #ff6b6b);
            border: none;
            color: white;
            padding: 0.5rem 1.5rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(212, 175, 55, 0.3);
            position: relative;
            z-index: 15;
        }

        .save-progression-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(212, 175, 55, 0.4);
        }

        .variation-header {
            margin-bottom: 1rem;
            text-align: center;
        }

        .variation-scales {
            font-size: 0.85rem;
            color: #A0A0A0;
        }

        .library-progression-display {
            display: flex;
            align-items: stretch;
            gap: 1rem;
        }

        .library-chord {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(212, 175, 55, 0.2);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chord-header {
            background: rgba(212, 175, 55, 0.15);
            padding: 0.5rem 1rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chord-symbol {
            font-weight: bold;
            color: #d4af37;
            font-size: 1.1rem;
        }

        .voicing-display {
            padding: 1rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .voicing-content {
            font-family: 'Courier New', monospace;
            font-size: 2.2rem;
            font-weight: bold;
            line-height: 1.4;
            color: #F5F5DC;
            background: rgba(0, 0, 0, 0.3);
            padding: 1.2rem;
            border-radius: 4px;
            white-space: pre-line;
            text-align: center;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .scale-indicator {
            font-size: 0.7rem;
            color: #8B7D6B;
            text-align: center;
            margin-top: 0.5rem;
            opacity: 0.7;
        }

        .voice-leading-connector {
            width: 80px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            position: relative;
            flex-shrink: 0;
            margin-top: 0;
        }

        .voice-leading-connector.library {
            margin-top: -8rem;
            z-index: 1;
            max-height: 8rem;
            overflow: visible;
            pointer-events: none;
        }

        .voice-leading-connector.library .connector-indicators {
            gap: 1rem;
        }

        .connector-lines {
            position: relative;
            width: 100%;
            height: 140px;
            background: rgba(45, 45, 60, 0.3);
            border-radius: 4px;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }

        .connector-indicators {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.3rem;
            background: rgba(45, 45, 60, 0.3);
            border-radius: 4px;
            border: 1px solid rgba(212, 175, 55, 0.2);
            min-height: fit-content;
        }

        .voice-line {
            position: absolute;
            left: 10px;
            right: 10px;
            height: 3px;
            border-radius: 2px;
            box-shadow: 0 0 4px rgba(0,0,0,0.3);
        }

        .voice-line.common-tone {
            background: #22c55e;
        }

        .voice-line.step-motion {
            background: #3b82f6;
        }

        .voice-line.leap-motion {
            background: #f59e0b;
        }

        .movement-summary {
            margin-top: 0.75rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border: 1px solid rgba(212, 175, 55, 0.1);
        }

        .movement-counts {
            display: flex;
            gap: 0.3rem;
            justify-content: center;
        }

        .count {
            padding: 0.3rem 0.5rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .count.common-tone {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .count.step-motion {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .count.total-semitones {
            background: rgba(139, 92, 246, 0.2);
            color: #8b5cf6;
        }

        .count.leap-motion {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        @media (max-width: 768px) {
            .progression-variations {
                grid-template-columns: 1fr;
            }
            
            .library-progression-display {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .chord-separator {
                transform: rotate(90deg);
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Jazz Piano Voicings</h1>
        
        <div class="mode-toggle">
            <button class="mode-btn" onclick="switchMode('progressions-library')">Progressions Library</button>
            <button class="mode-btn" onclick="switchMode('browse')">Browse Voicings</button>
            <button class="mode-btn" onclick="switchMode('progression')">Create Progression</button>
        </div>

        <!-- Browse Mode -->
        <div id="browse-mode" class="mode-section">
            <div id="browse-content">
                <!-- Content will be dynamically loaded -->
            </div>
        </div>

        <!-- Progressions Library Mode -->
        <div id="progressions-library-mode" class="mode-section">
            <div class="progressions-library">
                <h2>Progressions Library</h2>
                <div class="progression-selector">
                    <label for="progression-type">Progression Type:</label>
                    <select id="progression-type" onchange="loadProgressionType()">
                        <option value="V7-I">V7 - I</option>
                    </select>
                </div>
                
                <div class="library-layout">
                    <div class="top-note-line-nav">
                        <h3>Top-Note-Lines</h3>
                        <div class="nav-controls">
                            <input type="text" id="search-input" class="search-input" placeholder="Search top-note-lines..." oninput="filterTopNoteLines()">
                            <div class="sort-controls">
                                <span class="sort-label">Sort by:</span>
                                <div class="sort-switch">
                                    <input type="radio" id="sort-closeness" name="sort-method" value="closeness" checked onchange="refreshNavigation()">
                                    <label for="sort-closeness">Interval Closeness</label>
                                    <input type="radio" id="sort-count" name="sort-method" value="count" onchange="refreshNavigation()">
                                    <label for="sort-count">Progression Count</label>
                                </div>
                            </div>
                        </div>
                        <div id="top-note-line-list" class="top-note-line-list">
                            <!-- Navigation will be dynamically loaded -->
                        </div>
                    </div>
                    
                    <div class="top-note-line-browser">
                        <h3 id="current-filter-title">All Top-Note-Lines</h3>
                        <div id="progression-library-content">
                            <!-- Content will be dynamically loaded -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Progression Creator Mode -->
        <div id="progression-mode" class="mode-section active">
            <div class="progression-creator">
                <div class="controls-panel">
                    <div class="chord-bank">
                        <div class="root-selection" id="root-selection">
                            <div class="root-options" id="root-options">
                                <!-- Degree options will be populated -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="progression-area" id="progression-area">
                    <div class="progression-header">
                        <h2>Your Progression</h2>
                        <div class="progression-controls">
                            <button class="save-btn" onclick="saveProgression()">üíæ Save</button>
                            <button class="load-btn" onclick="loadProgression()">üìÅ Load</button>
                            <button class="clear-btn" onclick="clearProgression()">üóëÔ∏è Clear All</button>
                            <input type="file" id="file-input" accept=".json" style="display: none;" onchange="handleFileLoad(event)">
                        </div>
                    </div>
                    <div class="progression-container" id="progression-container">
                        <div class="empty-progression">
                            Click any Roman numeral degree to add it to your progression
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script>
        // Complete Pentatonic Voicing Data - ALL 131+ voicings from CSV files
        const voicingData = {
  major: {
    "Pentatonic": {
      1: ["1", "5", "9", "", "13", "3"],
      3: ["3", "1", "5", "", "9", "13"],
      5: ["5", "9", "13", "", "3", "1"],
      9: ["9", "13", "3", "", "1", "5"],
      13: ["13", "3", "1", "", "5", "9"]
    },
    "Pentatonic (from 5)": {
      3: ["3", "7", "5", "", "9", "13"],
      5: ["5", "9", "13", "", "3", "7"],
      7: ["7", "5", "9", "", "13", "3"],
      9: ["9", "13", "3", "", "7", "5"],
      13: ["13", "3", "7", "", "5", "9"]
    },
    "Pentatonic (from 2)": {
      3: ["3", "7", "‚ôØ11", "", "9", "13"],
      7: ["7", "‚ôØ11", "9", "", "13", "3"],
      9: ["9", "13", "3", "", "7", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "9", "13", "", "3", "7"],
      13: ["13", "3", "7", "", "‚ôØ11", "9"]
    }
  },

  minor: {
    "Pentatonic ‚ô≠3": {
      1: ["1", "5", "9", "", "13", "3"],
      5: ["5", "9", "13", "", "3", "1"],
      9: ["9", "13", "3", "", "1", "5"]
    },
    "Pentatonic (from 3)": {
      1: ["1", "5", "3", "", "7", "11"],
      3: ["3", "7", "11", "", "1", "5"],
      5: ["5", "3", "7", "", "11", "1"],
      7: ["7", "11", "1", "", "5", "3"],
      11: ["11", "1", "5", "", "3", "7"]
    },
    "Pentatonic \"minor 7\"": {
      1: ["1", "5", "9", "", "7", "3"],
      5: ["5", "9", "7", "", "3", "1"],
      9: ["9", "7", "3", "", "1", "5"]
    },
    "Pentatonic \"major 7\" (from 3)": {
      7: ["7", "11", "9", "", "5", "3"],
      11: ["11", "9", "5", "", "3", "7"]
    },
    "Pentatonic \"major 7 1-3-5-6-7\" (from 3)": {
      1: ["1", "5", "9", "", "7", "3"],
      5: ["5", "9", "7", "", "3", "1"],
      9: ["9", "7", "3", "", "1", "5"]
    },
    "Pentatonic \"dorian\"": {
      1: ["1", "13", "3", "", "7", "5"],
      5: ["5", "1", "13", "", "3", "7"],
      13: ["13", "3", "7", "", "5", "1"]
    },
    "Pentatonic ‚ô≠6 (from 5)": {
      "‚ôÆ7": ["‚ôÆ7", "5", "9", "", "13", "3"],
      9: ["9", "13", "3", "", "‚ôÆ7", "5"]
    },
    "Pentatonic \"minor-major 7\"": {
      5: ["5", "9", "‚ôÆ7", "", "3", "1"],
      9: ["9", "‚ôÆ7", "3", "", "1", "5"]
    }
  },

  dominant: {
    "Pentatonic \"dominant\"": {
      1: ["1", "5", "9", "", "7", "3"],
      3: ["3", "1", "5", "", "9", "7"],
      5: ["5", "9", "7", "", "3", "1"],
      7: ["7", "3", "1", "", "5", "9"],
      9: ["9", "7", "3", "", "1", "5"]
    },
    "Pentatonic \"dominant 1-3-5-6-7\"": {
      1: ["1", "13", "3", "", "7", "5"],
      5: ["5", "1", "13", "", "3", "7"],
      13: ["13", "3", "7", "", "5", "1"]
    },
    "Pentatonic ‚ô≠3 (from 5)": {
      5: ["5", "9", "13", "", "3", "7"],
      9: ["9", "13", "3", "", "7", "5"],
      13: ["13", "3", "7", "", "5", "9"]
    },
    "Pentatonic \"dominant\" ‚ô≠2 (‚ô≠9)": {
      1: ["1", "5", "‚ô≠9", "", "7", "3"],
      3: ["3", "1", "5", "", "‚ô≠9", "7"],
      5: ["5", "‚ô≠9", "7", "", "3", "1"],
      7: ["7", "3", "1", "", "5", "‚ô≠9"],
      "‚ô≠9": ["‚ô≠9", "7", "3", "", "1", "5"]
    },
    "Pentatonic \"dominant\" ‚ôØ2 (‚ôØ9)": {
      1: ["1", "5", "‚ôØ9", "", "7", "3"],
      5: ["5", "‚ôØ9", "7", "", "3", "1"],
      "‚ôØ9": ["‚ôØ9", "7", "3", "", "1", "5"]
    },
    "Pentatonic \"dominant\" ‚ô≠2 (from 6)": {
      5: ["5", "‚ô≠9", "13", "", "3", "7"],
      "‚ô≠9": ["‚ô≠9", "13", "3", "", "7", "5"],
      13: ["13", "3", "7", "", "5", "‚ô≠9"]
    },
    "Pentatonic \"dominant\" ‚ô≠2 (from ‚ô≠3)": {
      5: ["5", "‚ôØ9", "7", "", "3", "‚ô≠9"],
      "‚ô≠9": ["‚ô≠9", "5", "‚ôØ9", "", "7", "3"],
      "‚ôØ9": ["‚ôØ9", "7", "‚ô≠9", "", "‚ô≠9", "5"]
    },
    "Pentatonic \"dominant\" ‚ô≠2, ‚ô≠5": {
      1: ["1", "‚ôØ11", "‚ô≠9", "", "7", "3"],
      3: ["3", "1", "‚ôØ11", "", "‚ô≠9", "7"],
      7: ["7", "3", "1", "", "‚ôØ11", "‚ô≠9"],
      "‚ô≠9": ["‚ô≠9", "7", "3", "", "1", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "‚ô≠9", "7", "", "3", "1"]
    },
    "Pentatonic \"dominant\" ‚ô≠2, ‚ôØ5": {
      1: ["1", "‚ô≠13", "‚ô≠9", "", "7", "3"],
      3: ["3", "1", "‚ô≠13", "", "‚ô≠9", "7"],
      7: ["7", "3", "1", "", "‚ô≠13", "‚ô≠9"],
      "‚ô≠9": ["‚ô≠9", "7", "3", "", "1", "‚ô≠13"],
      "‚ô≠13": ["‚ô≠13", "‚ô≠9", "7", "", "3", "1"]
    },
    "Pentatonic \"dominant\" ‚ôØ2, ‚ô≠5": {
      1: ["1", "‚ôØ11", "‚ôØ9", "", "7", "3"],
      "‚ôØ9": ["‚ôØ9", "7", "3", "", "1", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "‚ôØ9", "7", "", "3", "1"]
    },
    "Pentatonic \"dominant\" ‚ôØ2, ‚ôØ5": {
      1: ["1", "‚ô≠13", "‚ôØ9", "", "7", "3"],
      "‚ôØ9": ["‚ôØ9", "7", "3", "", "1", "‚ô≠13"],
      "‚ô≠13": ["‚ô≠13", "‚ôØ9", "7", "", "3", "1"]
    },
    "Pentatonic ‚ô≠6 (from 2)": {
      9: ["9", "13", "3", "", "7", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "9", "13", "", "3", "7"],
      13: ["13", "3", "7", "", "‚ôØ11", "9"]
    },
    "Pentatonic \"minor-major 7\" (from 5)": {
      9: ["9", "13", "‚ôØ11", "", "7", "5"],
      13: ["13", "‚ôØ11", "7", "", "5", "9"]
    },
    "Pentatonic \"diminished steps\"": {
      3: ["3", "13", "‚ôØ11", "", "7", "5"],
      13: ["13", "9", "7", "", "5", "3"]
    },
    "WT (from 2)": {
      3: ["3", "7", "‚ôØ11", "", "9", "‚ô≠13"],
      7: ["7", "‚ôØ11", "9", "", "‚ô≠13", "3"],
      9: ["9", "‚ô≠13", "3", "", "7", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "9", "‚ô≠13", "", "3", "7"],
      "‚ô≠13": ["‚ô≠13", "3", "7", "", "‚ôØ11", "9"]
    },
    "WT (from 3)": {
      1: ["1", "‚ô≠13", "3", "", "7", "‚ôØ11"],
      3: ["3", "7", "‚ôØ11", "", "1", "‚ô≠13"],
      7: ["7", "‚ôØ11", "1", "", "‚ô≠13", "3"],
      "‚ôØ11": ["‚ôØ11", "1", "‚ô≠13", "", "3", "7"],
      "‚ô≠13": ["‚ô≠13", "3", "7", "", "‚ôØ11", "1"]
    },
    "WT (from ‚ô≠6)": {
      1: ["1", "‚ô≠13", "9", "", "7", "3"],
      3: ["3", "1", "‚ô≠13", "", "9", "7"],
      7: ["7", "3", "1", "", "‚ô≠13", "9"],
      9: ["9", "7", "3", "", "1", "‚ô≠13"],
      "‚ô≠13": ["‚ô≠13", "9", "7", "", "3", "1"]
    },
    "WT (from 7)": {
      1: ["1", "‚ôØ11", "9", "", "7", "3"],
      3: ["3", "1", "‚ôØ11", "", "9", "7"],
      9: ["9", "7", "3", "", "1", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "9", "7", "", "3", "1"]
    },
    "Pentatonic \"dominant\" (from ‚ô≠5)": {
      3: ["3", "7", "‚ôØ11", "", "‚ô≠9", "‚ô≠13"],
      7: ["7", "‚ôØ11", "‚ô≠9", "", "‚ô≠13", "3"],
      "‚ô≠9": ["‚ô≠9", "‚ô≠13", "3", "", "7", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "‚ô≠9", "‚ô≠13", "", "3", "7"],
      "‚ô≠13": ["‚ô≠13", "3", "7", "", "‚ôØ11", "‚ô≠9"]
    },
    "Pentatonic \"dominant\" ‚ô≠2 (from ‚ô≠5)": {
      "‚ô≠9": ["‚ô≠9", "13", "3", "", "7", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "‚ô≠9", "13", "", "3", "7"],
      13: ["13", "3", "7", "", "‚ôØ11", "‚ô≠9"]
    },
    "Pentatonic \"dominant\" (from ‚ô≠5) ‚ôØ2, ‚ô≠5": {
      1: ["1", "13", "3", "", "7", "‚ôØ11"],
      "‚ôØ11": ["‚ôØ11", "1", "13", "", "3", "7"],
      13: ["13", "3", "7", "", "‚ôØ11", "1"]
    },
    "Pentatonic ‚ô≠3 (from ‚ô≠2)": {
      "‚ô≠9": ["‚ô≠9", "‚ô≠13", "‚ôØ9", "", "7", "3"],
      "‚ôØ9": ["‚ôØ9", "7", "3", "", "‚ô≠9", "‚ô≠13"],
      "‚ô≠13": ["‚ô≠13", "‚ôØ9", "7", "", "3", "‚ô≠9"]
    }
  },

  sus: {
    "Pentatonic (from 7)": {
      1: ["1", "5", "9", "", "7", "4"],
      4: ["4", "1", "5", "", "9", "7"],
      5: ["5", "9", "7", "", "4", "1"],
      7: ["7", "4", "1", "", "5", "9"],
      9: ["9", "7", "4", "", "1", "5"]
    },
    "Pentatonic \"major 7\" (from 7)": {
      1: ["1", "13", "9", "", "7", "4"],
      4: ["4", "1", "13", "", "9", "7"],
      13: ["13", "9", "7", "", "4", "1"]
    },
    "Pentatonic \"minor 7\" (from 5)": {
      5: ["5", "9", "13", "", "4", "7"],
      9: ["9", "13", "4", "", "7", "5"],
      13: ["13", "4", "7", "", "5", "9"]
    },
    "Pentatonic ‚ô≠3 (from 7)": {
      1: ["1", "5", "‚ô≠9", "", "7", "4"],
      4: ["4", "1", "5", "", "‚ô≠9", "7"],
      5: ["5", "‚ô≠9", "7", "", "4", "1"],
      7: ["7", "4", "1", "", "5", "‚ô≠9"],
      "‚ô≠9": ["‚ô≠9", "7", "4", "", "1", "5"]
    },
    "Pentatonic \"minor 7\" (from 7)": {
      1: ["1", "‚ô≠13", "‚ô≠9", "", "7", "4"],
      4: ["4", "1", "‚ô≠13", "", "‚ô≠9", "7"],
      7: ["7", "4", "1", "", "‚ô≠13", "‚ô≠9"],
      "‚ô≠9": ["‚ô≠9", "7", "4", "", "1", "‚ô≠13"],
      "‚ô≠13": ["‚ô≠13", "‚ô≠9", "7", "", "4", "1"]
    },
    "Pentatonic \"dorian\" (from 7)": {
      4: ["4", "7", "5", "", "‚ô≠9", "‚ô≠13"],
      5: ["5", "‚ô≠9", "‚ô≠13", "", "4", "7"],
      7: ["7", "5", "‚ô≠9", "", "‚ô≠13", "4"]
    },
    "Pentatonic (from ‚ô≠2)": {
      4: ["4", "‚ô≠9", "‚ô≠13", "", "‚ôØ9", "7"],
      7: ["7", "4", "‚ô≠9", "", "‚ô≠13", "‚ôØ9"],
      "‚ô≠9": ["‚ô≠9", "‚ô≠13", "‚ôØ9", "", "7", "4"],
      "‚ôØ9": ["‚ôØ9", "7", "4", "", "‚ô≠9", "‚ô≠13"],
      "‚ô≠13": ["‚ô≠13", "‚ôØ9", "7", "", "4", "‚ô≠9"]
    }
  },

  "half-diminished": {
    "Pentatonic ‚ô≠3 (from 3)": {
      1: ["1", "5", "3", "", "7", "11"],
      3: ["3", "7", "11", "", "1", "5"],
      5: ["5", "3", "7", "", "11", "1"],
      7: ["7", "11", "1", "", "5", "3"],
      11: ["11", "1", "5", "", "3", "7"]
    },
    "Pentatonic \"Super-Locrian\"": {
      1: ["1", "5", "9", "", "7", "3"],
      5: ["5", "9", "7", "", "3", "1"],
      9: ["9", "7", "3", "", "1", "5"]
    },
    "Pentatonic \"minor-major 7\" (from 3)": {
      7: ["7", "11", "9", "", "5", "3"],
      11: ["11", "9", "5", "", "3", "7"]
    },
    "Pentatonic \"diminished steps\"": {
      1: ["1", "11", "9", "", "5", "3"],
      11: ["11", "9", "5", "", "3", "1"]
    },
    "Pentatonic ‚ô≠6 (from 7)": {
      9: ["9", "7", "11", "", "1", "5"],
      11: ["11", "1", "5", "", "9", "7"]
    }
  },

  diminished: {
    "Pentatonic \"dim-maj7\"": {
      5: ["5", "9", "maj7", "", "3", "1"],
      9: ["9", "maj7", "3", "", "1", "5"]
    },
    "Pentatonic \"dim-maj7\" (from 3)": {
      7: ["7", "11", "9", "", "5", "3"],
      11: ["11", "9", "5", "", "3", "7"]
    },
    "Pentatonic \"dim-maj7\" (from 5)": {
      1: ["1", "13", "11", "", "7", "5"],
      13: ["13", "11", "7", "", "5", "1"]
    },
    "Pentatonic \"dim-maj7\" (from 7)": {
      3: ["3", "maj7", "13", "", "1", "7"],
      "maj7": ["maj7", "13", "1", "", "7", "3"]
    },
    "Pentatonic \"Dominant\" ‚ô≠2 (from 2)": {
      1: ["1", "5", "9", "", "7", "3"],
      5: ["5", "9", "7", "", "3", "1"],
      9: ["9", "7", "3", "", "1", "5"]
    },
    "Pentatonic \"Dominant\" ‚ôØ2 (from 2)": {
      1: ["1", "5", "9", "", "7", "3"],
      9: ["9", "7", "11", "", "1", "5"]
    },
    "Pentatonic \"Dominant\" ‚ô≠2 (from 4)": {
      3: ["3", "7", "11", "", "1", "5"],
      7: ["7", "11", "1", "", "5", "3"],
      11: ["11", "1", "5", "", "7", "3"]
    },
    "Pentatonic \"Dominant\" ‚ô≠2 (from 6)": {
      1: ["1", "13", "3", "", "7", "5"],
      5: ["5", "1", "13", "", "3", "7"],
      13: ["13", "3", "7", "", "5", "1"]
    },
    "Pentatonic \"Dominant\" ‚ô≠2 (from maj7)": {
      3: ["3", "maj7", "5", "", "1", "7"],
      7: ["7", "3", "maj7", "", "5", "1"],
      "maj7": ["maj7", "5", "1", "", "7", "3"]
    }
  }
};

        // Note-to-semitone conversion system for voice leading analysis
        const noteToSemitones = {
            // Basic chord tones and extensions
            '1': 0, 'b2': 1, '2': 2, 'b3': 3, '3': 4, '4': 5, 'b5': 6, '5': 7, 
            '#5': 8, 'b6': 8, '6': 9, 'bb7': 9, 'b7': 10, '‚ôÆ7': 11, '7': 11,
            '8': 12, 'b9': 13, '9': 14, '#9': 15, '10': 16, '11': 17, '#11': 18, 'b13': 20, '13': 21,
            
            // Jazz notation variants
            '‚ô≠2': 1, '‚ô≠3': 3, '‚ô≠5': 6, '‚ôØ5': 8, '‚ô≠6': 8, '‚ô≠‚ô≠7': 9, '‚ô≠7': 10,
            '‚ô≠9': 13, '‚ôØ9': 15, '‚ôØ11': 18, '‚ô≠13': 20
        };

        function getNoteInSemitones(note, chordType) {
            if (!note || note === '') return null;
            
            // Handle special cases and normalize notation
            let normalizedNote = note.toString().trim();
            
            // Convert various notations to standard
            if (normalizedNote === '‚ôÆ7') normalizedNote = '7';
            
            // Get base semitone value
            const semitones = noteToSemitones[normalizedNote];
            if (semitones !== undefined) return semitones;
            
            // Fallback for unknown notes
            console.warn(`Unknown note: ${note}`);
            return null;
        }

        // Voice Leading Analysis Functions
        function analyzeVoiceLeading(chord1, chord2) {
            if (!chord1.selectedVoicing || !chord2.selectedVoicing) return null;
            
            const voicing1 = chord1.selectedVoicing.split('\n');
            const voicing2 = chord2.selectedVoicing.split('\n');
            
            const chord1Type = getChordType(chord1.symbol);
            const chord2Type = getChordType(chord2.symbol);
            
            const movements = [];
            
            // Analyze each voice position including gaps
            for (let i = 0; i < Math.max(voicing1.length, voicing2.length); i++) {
                const note1 = voicing1[i];
                const note2 = voicing2[i];
                
                // Only analyze if both notes exist and are not empty
                if (note1 && note2 && note1.trim() !== '' && note2.trim() !== '') {
                    const movement = calculateVoiceMovement(note1, note2, chord1.symbol, chord1Type, chord2.symbol, chord2Type);
                    movements.push({
                        position: i,
                        from: note1,
                        to: note2,
                        ...movement
                    });
                }
            }
            
            return movements;
        }
        
        function getActualPitchInSemitones(chordDegree, chordSymbol, chordType) {
            // Get the root note offset for the chord symbol
            const rootOffset = getChordRootOffset(chordSymbol);
            let degreeOffset = getNoteInSemitones(chordDegree, chordType);
            
            if (rootOffset === null || degreeOffset === null) return null;
            
            // The chord degree already includes alterations (‚ô≠9, ‚ôØ11, etc.)
            // But we need to apply basic chord type modifications to unaltered degrees
            if (chordType === 'minor' && chordDegree === '3') {
                degreeOffset = 3; // ‚ô≠3
            } else if (chordType === 'minor' && chordDegree === '7') {
                degreeOffset = 10; // ‚ô≠7
            } else if ((chordType === 'dominant' || chordType === 'sus') && chordDegree === '7') {
                degreeOffset = 10; // ‚ô≠7
            }
            
            return (rootOffset + degreeOffset) % 12;
        }
        
        function getChordRootOffset(chordSymbol) {
            // Map Roman numeral to semitone offset from tonic
            // Assuming major key context for now
            const romanToSemitones = {
                'I': 0, 'i': 0,
                '‚ô≠II7': 1, '‚ô≠ii': 1,
                'ii': 2, 'II': 2,
                '‚ô≠III': 3, '‚ô≠iii': 3,
                'iii': 4, 'III': 4,
                'IV': 5, 'iv': 5,
                'Vsus': 7, 'V7': 7, 'V': 7,
                '‚ô≠VI': 8, '‚ô≠vi': 8,
                'vi': 9, 'VI': 9,
                '‚ô≠VII': 10, '‚ô≠vii': 10
            };
            
            // Handle secondary dominants
            if (chordSymbol.includes('/')) {
                const [chordPart, targetPart] = chordSymbol.split('/');
                const targetOffset = romanToSemitones[targetPart] || 0;
                
                // Dominant is 5 semitones above target
                if (chordPart.includes('V7') || chordPart.includes('Vsus')) {
                    return (targetOffset + 7) % 12;
                }
            }
            
            return romanToSemitones[chordSymbol] || 0;
        }

        function calculateVoiceMovement(note1, note2, chord1Symbol, chord1Type, chord2Symbol, chord2Type) {
            const pitch1 = getActualPitchInSemitones(note1, chord1Symbol, chord1Type);
            const pitch2 = getActualPitchInSemitones(note2, chord2Symbol, chord2Type);
            
            if (pitch1 === null || pitch2 === null) {
                return { interval: null, direction: 'unknown', type: 'unknown' };
            }
            
            // Calculate interval (allowing for octave equivalence)
            let interval = pitch2 - pitch1;
            
            // Normalize to within one octave for analysis
            while (interval > 6) interval -= 12;
            while (interval < -6) interval += 12;
            
            const direction = interval === 0 ? 'same' : interval > 0 ? 'up' : 'down';
            const absInterval = Math.abs(interval);
            
            let type, symbol;
            if (interval === 0) {
                type = 'common';
                symbol = '=';
            } else if (absInterval <= 2) {
                // 1-2 semitones = ¬Ω-1 semitone steps (blue)
                type = 'step';
                if (absInterval === 1) {
                    symbol = direction === 'up' ? '‚Üë¬Ω' : '‚Üì¬Ω';
                } else {
                    symbol = direction === 'up' ? '‚Üë1' : '‚Üì1';
                }
            } else {
                // >2 semitones = >1 semitone leaps (orange)
                type = 'leap';
                const semitoneCount = absInterval % 2 === 0 ? absInterval / 2 : `${Math.floor(absInterval / 2)}¬Ω`;
                symbol = direction === 'up' ? `‚Üë${semitoneCount}` : `‚Üì${semitoneCount}`;
            }
            
            return {
                interval,
                direction,
                type,
                symbol,
                semitones: absInterval,  // Keep semitones field for consistency
                absInterval
            };
        }
        
        function getVoiceLeadingColor(type) {
            switch (type) {
                case 'common': return '#4CAF50'; // Green for common tones
                case 'step': return '#2196F3'; // Blue for smooth steps
                case 'leap': return '#FF9800'; // Orange for leaps
                default: return '#757575'; // Gray for unknown
            }
        }
        
        function getVoiceLeadingSummary(movements) {
            if (!movements || movements.length === 0) return 'No voice leading data available';
            
            const commonTones = movements.filter(m => m.type === 'common').length;
            const stepMotions = movements.filter(m => m.type === 'step').length;
            const leaps = movements.filter(m => m.type === 'leap').length;
            
            // Calculate total semitones
            const totalSemitones = movements.reduce((sum, m) => {
                return sum + (m.semitones || m.absInterval || 0);
            }, 0);
            
            const details = movements.map(m => 
                `Voice ${m.position + 1}: ${m.from} ‚Üí ${m.to} (${m.symbol})`
            ).join('\n');
            
            // Create compact summary: "4S 2L" format
            const summaryParts = [];
            if (totalSemitones > 0) summaryParts.push(`${totalSemitones}S`);
            if (leaps > 0) summaryParts.push(`${leaps}L`);
            const compactSummary = summaryParts.length > 0 ? summaryParts.join(' ') : '0S';
            
            return `Voice Leading Summary: ${compactSummary}
${commonTones} common tone${commonTones !== 1 ? 's' : ''}
${stepMotions} step motion${stepMotions !== 1 ? 's' : ''}
${leaps} leap${leaps !== 1 ? 's' : ''}

Details:
${details}`;
        }

        let currentProgression = [];
        let draggedChord = null;
        let selectedRoot = null;

        function switchMode(mode) {
            const modeButtons = document.querySelectorAll('.mode-btn');
            const browseMode = document.getElementById('browse-mode');
            const progressionMode = document.getElementById('progression-mode');
            const progressionsLibraryMode = document.getElementById('progressions-library-mode');

            // Remove active class from all buttons and modes
            modeButtons.forEach(btn => btn.classList.remove('active'));
            browseMode.classList.remove('active');
            progressionMode.classList.remove('active');
            progressionsLibraryMode.classList.remove('active');

            if (mode === 'browse') {
                document.querySelector('.mode-btn[onclick="switchMode(\'browse\')"]').classList.add('active');
                browseMode.classList.add('active');
                loadBrowseMode();
            } else if (mode === 'progressions-library') {
                document.querySelector('.mode-btn[onclick="switchMode(\'progressions-library\')"]').classList.add('active');
                progressionsLibraryMode.classList.add('active');
                loadProgressionsLibraryMode();
            } else {
                document.querySelector('.mode-btn[onclick="switchMode(\'progression\')"]').classList.add('active');
                progressionMode.classList.add('active');
                loadProgressionMode();
            }
        }

        function loadBrowseMode() {
            const browseContent = document.getElementById('browse-content');
            let html = '';

            // Define column order for each chord type
            const topNoteColumns = {
                major: ['1', '3', '5', '7', '9', '‚ôØ11', '13'],
                minor: ['1', '3', '5', '7', '‚ôÆ7', '9', '11', '13'],
                dominant: ['1', '3', '5', '7', '‚ô≠9', '9', '‚ôØ9', '‚ôØ11', '‚ô≠13', '13'],
                sus: ['1', '4', '5', '7', '‚ô≠9', '9', '‚ôØ9', '‚ô≠13', '13'],
                'half-diminished': ['1', '3', '5', '7', '9', '11'],
                'diminished': ['1', '3', '5', '7', 'maj7', '9', '11', '13']
            };


            Object.entries(voicingData).forEach(([chordType, scales]) => {
                const chordTypeTitle = chordType.charAt(0).toUpperCase() + chordType.slice(1) + ' Chords';
                const columns = topNoteColumns[chordType];
                
                // Get only columns that actually have voicings in this chord type
                const usedColumns = [];
                const allTopNotes = new Set();
                Object.values(scales).forEach(voicings => {
                    Object.keys(voicings).forEach(topNote => allTopNotes.add(topNote));
                });
                columns.forEach(col => {
                    if (allTopNotes.has(col)) {
                        usedColumns.push(col);
                    }
                });
                
                const gridCols = `repeat(${usedColumns.length}, 1fr)`;
                
                html += `
                    <div class="chord-type">
                        <h2>${chordTypeTitle}</h2>
                        
                        <div class="note-headers" style="grid-template-columns: ${gridCols};">
                            ${usedColumns.map(note => `<div class="note-header">${note}</div>`).join('')}
                        </div>
                        
                        <div class="voicing-table">
                `;

                Object.entries(scales).forEach(([scaleName, voicings]) => {
                    const voicingCount = Object.keys(voicings).length;
                    html += `
                        <div class="scale-row">
                            <div class="scale-name">${scaleName}</div>
                            <div class="voicing-grid" style="grid-template-columns: ${gridCols};">
                    `;

                    // Create cells in the used column order
                    usedColumns.forEach(topNote => {
                        if (voicings[topNote]) {
                            // Convert array format to display string with top note emphasis
                            let voicingDisplay;
                            const voicing = voicings[topNote];
                            if (Array.isArray(voicing)) {
                                const notes = voicing.map((note, index) => {
                                    if (index === 0 && note.trim() !== '') {
                                        return `<span class="top-note">${note}</span>`;
                                    }
                                    return note;
                                });
                                voicingDisplay = notes.join('\n');
                            } else {
                                // For string format, emphasize first non-empty line
                                const lines = voicing.split('\n');
                                const firstNoteIndex = lines.findIndex(line => line.trim() !== '');
                                if (firstNoteIndex >= 0) {
                                    lines[firstNoteIndex] = `<span class="top-note">${lines[firstNoteIndex]}</span>`;
                                }
                                voicingDisplay = lines.join('\n');
                            }
                            html += `
                                <div class="voicing-cell" data-chord-type="${chordType}" data-scale="${scaleName}" data-top-note="${topNote}">
                                    <div class="chord-notes">${voicingDisplay}</div>
                                </div>
                            `;
                        } else {
                            // Empty cell for missing voicings
                            html += `
                                <div class="voicing-cell empty-cell">
                                    <div class="chord-notes">-</div>
                                </div>
                            `;
                        }
                    });

                    html += `
                            </div>
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            browseContent.innerHTML = html;
        }

        function loadProgressionMode() {
            const primaryDegrees = [
                { symbol: 'I', type: 'major', display: 'I (major)' },
                { symbol: 'i', type: 'minor', display: 'i (minor)' },
                { symbol: '‚ô≠II7', type: 'dominant', display: '‚ô≠II7 (dominant)' },
                { symbol: 'ii', type: 'minor', display: 'ii (minor)' },
                { symbol: 'ii√∏', type: 'half-diminished', display: 'ii√∏ (half-diminished)' },
                { symbol: '‚ô≠III', type: 'major', display: '‚ô≠III (major)' },
                { symbol: 'iii', type: 'minor', display: 'iii (minor)' },
                { symbol: 'IV', type: 'major', display: 'IV (major)' },
                { symbol: 'iv', type: 'minor', display: 'iv (minor)' },
                { symbol: 'Vsus', type: 'sus', display: 'Vsus (sus)' },
                { symbol: 'V7', type: 'dominant', display: 'V7 (dominant)' },
                { symbol: '‚ô≠VI', type: 'major', display: '‚ô≠VI (major)' },
                { symbol: 'vi', type: 'minor', display: 'vi (minor)' },
                { symbol: '‚ô≠VII', type: 'dominant', display: '‚ô≠VII (dominant)' },
                { symbol: 'vii¬∫7', type: 'diminished', display: 'vii¬∫7 (diminished)' }
            ];

            const secondaryHarmony = [
                { symbol: 'Vsus/ii', type: 'sus', display: 'Vsus/ii (sus)' },
                { symbol: 'V7/ii', type: 'dominant', display: 'V7/ii (dominant)' },
                { symbol: 'ii√∏/', type: 'half-diminished', display: 'ii√∏/ (half-diminished)' },
                { symbol: 'Vsus/iii', type: 'sus', display: 'Vsus/iii (sus)' },
                { symbol: 'V7/iii', type: 'dominant', display: 'V7/iii (dominant)' },
                { symbol: 'Vsus/‚ô≠III', type: 'sus', display: 'Vsus/‚ô≠III (sus)' },
                { symbol: 'V7/‚ô≠III', type: 'dominant', display: 'V7/‚ô≠III (dominant)' },
                { symbol: 'Vsus/IV', type: 'sus', display: 'Vsus/IV (sus)' },
                { symbol: 'V7/IV', type: 'dominant', display: 'V7/IV (dominant)' },
                { symbol: 'Vsus/V', type: 'sus', display: 'Vsus/V (sus)' },
                { symbol: 'V7/V', type: 'dominant', display: 'V7/V (dominant)' },
                { symbol: 'Vsus/‚ô≠VI', type: 'sus', display: 'Vsus/‚ô≠VI (sus)' },
                { symbol: 'V7/‚ô≠VI', type: 'dominant', display: 'V7/‚ô≠VI (dominant)' },
                { symbol: 'Vsus/vi', type: 'sus', display: 'Vsus/vi (sus)' },
                { symbol: 'V7/vi', type: 'dominant', display: 'V7/vi (dominant)' },
                { symbol: 'V/', type: 'dominant', display: 'V/ (dominant)' },
                { symbol: '‚ô≠II7/', type: 'dominant', display: '‚ô≠II7/ (dominant)' },
                { symbol: 'vii¬∫7/', type: 'diminished', display: 'vii¬∫7/ (diminished)' },
                { symbol: 'rel. ii', type: 'minor', display: 'rel. ii (minor)' }
            ];

            // Load degree options
            const rootOptions = document.getElementById('root-options');
            let degreeHtml = '<h4 style="grid-column: 1/-1; color: #8B7D6B; margin: 0.5rem 0; text-align: center;">Primary Degrees</h4>';
            
            primaryDegrees.forEach(degree => {
                degreeHtml += `<div class="root-option" data-chord="${degree.symbol}" data-type="${degree.type}" draggable="true">${degree.symbol}</div>`;
            });

            degreeHtml += '<h4 style="grid-column: 1/-1; color: #8B7D6B; margin: 1rem 0 0.5rem 0; text-align: center;">Secondary Harmony</h4>';
            
            secondaryHarmony.forEach(degree => {
                degreeHtml += `<div class="root-option" data-chord="${degree.symbol}" data-type="${degree.type}" draggable="true">${degree.symbol}</div>`;
            });

            rootOptions.innerHTML = degreeHtml;

            // Add degree selection listeners - single click to add
            setupDegreeButtonListeners();
        }

        function setupDegreeButtonListeners() {
            const rootOptions = document.querySelectorAll('.root-option');
            
            rootOptions.forEach(option => {
                // Add click listener
                option.addEventListener('click', (e) => {
                    // Prevent adding chord if it was just dragged
                    if (isDragging) {
                        e.preventDefault();
                        return;
                    }
                    
                    const chord = option.dataset.chord;
                    if (chord) {
                        addChordToProgression(chord);
                    }
                });

                // Add drag listeners
                option.addEventListener('dragstart', (e) => {
                    isDragging = true;
                    draggedElement = option;
                    draggedNewChord = option.dataset.chord;
                    draggedChordId = null;
                    
                    e.dataTransfer.effectAllowed = 'copy';
                });

                option.addEventListener('dragend', (e) => {
                    // Delay clearing isDragging to prevent click events
                    setTimeout(() => {
                        isDragging = false;
                    }, 100);
                    
                    clearDropIndicators();
                    draggedElement = null;
                    draggedNewChord = null;
                });
            });
        }


        function addChordToProgression(chord) {
            const chordType = getChordType(chord);
            let selectedVoicing = null;
            
            // If there's a previous chord, find the closest top note
            if (currentProgression.length > 0) {
                const lastChord = currentProgression[currentProgression.length - 1];
                selectedVoicing = getClosestVoicing(chordType, lastChord, chord);
            } else {
                // First chord - use default first voicing
                selectedVoicing = getFirstVoicing(chordType, chord);
            }
            
            const chordData = {
                id: Date.now(),
                symbol: chord,
                selectedVoicing: null,
                selectedVoicingKey: null,
                currentTopNote: selectedVoicing ? selectedVoicing.topNote : null,
                currentVoicingIndex: 0,
                scaleName: selectedVoicing ? selectedVoicing.scaleName : null,
                voicingWithPositions: null
            };
            
            // Use updateChordVoicing to properly set up the voicing data
            if (selectedVoicing) {
                updateChordVoicing(chordData, selectedVoicing);
            }
            
            currentProgression.push(chordData);
            renderProgression();
        }

        function removeChordFromProgression(id) {
            currentProgression = currentProgression.filter(chord => chord.id !== id);
            renderProgression();
        }

        function renderProgression() {
            const container = document.getElementById('progression-container');
            
            if (currentProgression.length === 0) {
                container.innerHTML = '<div class="empty-progression">Click any Roman numeral degree to add it to your progression</div>';
                return;
            }

            let html = '';
            currentProgression.forEach((chord, index) => {
                const chordType = getChordType(chord.symbol);
                const allTopNotes = getAllTopNotes(chordType, chord.symbol);
                const currentTopNote = chord.currentTopNote;
                const voicingsForCurrentTopNote = getVoicingsForTopNote(chordType, currentTopNote, chord.symbol);
                
                // Find current top note index
                const topNoteIndex = allTopNotes.indexOf(currentTopNote);
                const canGoToPrevTopNote = topNoteIndex > 0;
                const canGoToNextTopNote = topNoteIndex < allTopNotes.length - 1;
                
                // Find current voicing index within the top note
                const canGoToPrevVoicing = chord.currentVoicingIndex > 0;
                const canGoToNextVoicing = chord.currentVoicingIndex < voicingsForCurrentTopNote.length - 1;
                
                html += `
                    <div class="chord-slot" data-chord-id="${chord.id}" draggable="true">
                        <div class="chord-header">
                            <span class="drag-handle">‚â°</span>
                            <span class="chord-symbol">${chord.symbol}</span>
                            <button class="remove-chord" onclick="removeChordFromProgression(${chord.id})">√ó</button>
                        </div>
                        <div class="voicing-selector">
                            <div class="voicing-navigation">
                                <div class="top-note-selector">
                                    <div class="top-note-label">Top Note</div>
                                    <select class="top-note-dropdown" onchange="changeTopNoteFromDropdown(${chord.id}, this.value)">
                                        ${allTopNotes.map(topNote => 
                                            `<option value="${topNote}" ${topNote === currentTopNote ? 'selected' : ''}>${topNote}</option>`
                                        ).join('')}
                                    </select>
                                </div>
                                <div class="voicing-navigation-controls">
                                    <button class="nav-arrow" onclick="changeVoicing(${chord.id}, -1)" ${!canGoToPrevVoicing ? 'disabled' : ''}>‚óÄ</button>
                                    <div class="voicing-counter">${chord.currentVoicingIndex + 1}/${voicingsForCurrentTopNote.length}</div>
                                    <button class="nav-arrow" onclick="changeVoicing(${chord.id}, 1)" ${!canGoToNextVoicing ? 'disabled' : ''}>‚ñ∂</button>
                                </div>
                            </div>
                        </div>
                        <div class="selected-voicing" id="voicing-${chord.id}">
                            ${chord.voicingWithPositions ? 
                                `<div class="voicing-with-positions">
                                    ${chord.voicingWithPositions.map(voiceData => {
                                        if (voiceData === '') return '<div style="height: 0.5rem;"></div>';
                                        return `<div class="voice-position ${voiceData.isTopNote ? 'top-note' : ''}">
                                            <span class="voice-note">${voiceData.note}</span>
                                        </div>`;
                                    }).join('')}
                                </div>` 
                                : (chord.selectedVoicing || 'No voicing selected')
                            }
                            ${chord.selectedVoicing ? `<div class="voicing-scale-name">${chord.scaleName || ''}</div>` : ''}
                        </div>
                    </div>
                `;
                
                // Add voice leading connector if not the last chord
                if (index < currentProgression.length - 1) {
                    const nextChord = currentProgression[index + 1];
                    const movements = analyzeVoiceLeading(chord, nextChord);
                    
                    if (movements && movements.length > 0) {
                        const summary = getVoiceLeadingSummary(movements);
                        
                        // Create movement indicators that match the exact structure of chord.voicingWithPositions
                        const movementHtml = [];
                        
                        // Use the same structure as the first chord's voicingWithPositions
                        if (chord.voicingWithPositions) {
                            chord.voicingWithPositions.forEach((voiceData, index) => {
                                if (voiceData === '') {
                                    // Empty gap - add spacing
                                    movementHtml.push('<div style="height: 0.5rem;"></div>');
                                } else {
                                    // Find movement for this actual voice position
                                    const movement = movements.find(m => m.position === index);
                                    
                                    if (movement) {
                                        movementHtml.push(`<div class="voice-movement ${movement.type}" title="Voice ${movement.position + 1}: ${movement.from} ‚Üí ${movement.to}">${movement.symbol}</div>`);
                                    } else {
                                        // Always show a movement indicator to maintain alignment
                                        movementHtml.push(`<div class="voice-movement" style="opacity: 0.3; background: rgba(255,255,255,0.1);">‚Äì</div>`);
                                    }
                                }
                            });
                        } else {
                            // Fallback: create indicators based on movements only
                            movements.forEach(movement => {
                                movementHtml.push(`<div class="voice-movement ${movement.type}" title="Voice ${movement.position + 1}: ${movement.from} ‚Üí ${movement.to}">${movement.symbol}</div>`);
                            });
                        }
                        
                        html += `
                            <div class="voice-leading-connector" title="${summary}">
                                ${movementHtml.join('')}
                            </div>
                        `;
                    }
                }
            });

            container.innerHTML = html;
            
            // Add drag event listeners to chord slots
            setupDragAndDrop();
        }

        // Drag and drop functionality
        let draggedElement = null;
        let draggedChordId = null;
        let draggedNewChord = null;
        let isDragging = false;

        function setupDragAndDrop() {
            const container = document.getElementById('progression-container');
            const chordSlots = container.querySelectorAll('.chord-slot');
            
            // Setup drag for existing chord slots
            chordSlots.forEach(slot => {
                setupChordSlotDrag(slot);
            });
            
            // Setup drop zones on container (only if not already set)
            if (!container.hasAttribute('data-drop-setup')) {
                setupDropZones(container);
                container.setAttribute('data-drop-setup', 'true');
            }
        }

        function setupChordSlotDrag(slot) {
            slot.addEventListener('dragstart', (e) => {
                isDragging = true;
                draggedElement = slot;
                draggedChordId = parseInt(slot.dataset.chordId);
                draggedNewChord = null;
                
                slot.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            slot.addEventListener('dragend', (e) => {
                setTimeout(() => {
                    isDragging = false;
                }, 100);
                
                slot.classList.remove('dragging');
                clearDropIndicators();
                draggedElement = null;
                draggedChordId = null;
            });

            slot.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (draggedElement && draggedElement !== slot) {
                    e.dataTransfer.dropEffect = 'move';
                    showDropIndicator(slot);
                }
            });

            slot.addEventListener('dragleave', (e) => {
                slot.classList.remove('drag-over');
            });

            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                if (draggedElement && draggedElement !== slot) {
                    handleChordDrop(slot);
                }
            });
        }


        function setupDropZones(container) {
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (draggedElement) {
                    e.dataTransfer.dropEffect = draggedNewChord ? 'copy' : 'move';
                }
            });

            container.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (draggedNewChord && isDragging) {
                    // Calculate drop position
                    const dropIndex = getDropIndex(e.clientX);
                    addChordAtPosition(draggedNewChord, dropIndex);
                }
            });
        }

        function handleChordDrop(targetSlot) {
            if (draggedChordId) {
                const targetChordId = parseInt(targetSlot.dataset.chordId);
                reorderChords(draggedChordId, targetChordId);
            }
        }

        function reorderChords(draggedId, targetId) {
            const draggedIndex = currentProgression.findIndex(c => c.id === draggedId);
            const targetIndex = currentProgression.findIndex(c => c.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // Remove the dragged chord
            const [draggedChord] = currentProgression.splice(draggedIndex, 1);
            
            // Insert it at the target position
            currentProgression.splice(targetIndex, 0, draggedChord);
            
            // Re-analyze voice leading for the entire progression
            reanalyzeProgression();
            
            renderProgression();
        }

        function getDropIndex(clientX) {
            const container = document.getElementById('progression-container');
            const slots = container.querySelectorAll('.chord-slot');
            
            if (slots.length === 0) return 0;
            
            let dropIndex = slots.length;
            
            for (let i = 0; i < slots.length; i++) {
                const rect = slots[i].getBoundingClientRect();
                const slotMiddle = rect.left + rect.width / 2;
                
                if (clientX < slotMiddle) {
                    dropIndex = i;
                    break;
                }
            }
            
            return dropIndex;
        }

        function addChordAtPosition(chord, position) {
            const chordType = getChordType(chord);
            let selectedVoicing = null;
            
            // Find voice leading context for the new position
            let prevChord = null;
            let nextChord = null;
            
            if (position > 0) {
                prevChord = currentProgression[position - 1];
            }
            if (position < currentProgression.length) {
                nextChord = currentProgression[position];
            }
            
            // Choose voicing based on context
            if (prevChord) {
                selectedVoicing = getClosestVoicing(chordType, prevChord, chord);
            } else if (nextChord) {
                selectedVoicing = getClosestVoicing(chordType, nextChord, chord);
            } else {
                selectedVoicing = getFirstVoicing(chordType, chord);
            }
            
            const chordData = {
                id: Date.now(),
                symbol: chord,
                selectedVoicing: null,
                selectedVoicingKey: null,
                currentTopNote: selectedVoicing ? selectedVoicing.topNote : null,
                currentVoicingIndex: 0,
                scaleName: selectedVoicing ? selectedVoicing.scaleName : null,
                voicing: selectedVoicing ? selectedVoicing.voicing : null
            };
            
            if (selectedVoicing) {
                updateChordVoicing(chordData, selectedVoicing);
            }
            
            // Insert at specified position
            currentProgression.splice(position, 0, chordData);
            
            // Re-analyze voice leading for affected chords
            reanalyzeProgression();
            
            renderProgression();
        }

        function reanalyzeProgression() {
            // Re-analyze voice leading for all chord transitions
            for (let i = 1; i < currentProgression.length; i++) {
                const prevChord = currentProgression[i - 1];
                const currentChord = currentProgression[i];
                const chordType = getChordType(currentChord.symbol);
                
                // Find closest voicing based on previous chord
                const closestVoicing = getClosestVoicing(chordType, prevChord, currentChord.symbol);
                if (closestVoicing) {
                    updateChordVoicing(currentChord, closestVoicing);
                }
            }
        }

        function showDropIndicator(slot) {
            clearDropIndicators();
            slot.classList.add('drag-over');
        }

        function clearDropIndicators() {
            const slots = document.querySelectorAll('.chord-slot');
            slots.forEach(slot => {
                slot.classList.remove('drag-over');
            });
        }

        function getChordType(symbol) {
            if (symbol.includes('√∏')) return 'half-diminished';
            if (symbol.includes('¬∫')) return 'diminished';
            if (symbol.includes('sus')) return 'sus';
            if (symbol.includes('7') || symbol.includes('‚ô≠VII')) return 'dominant';
            if (symbol === 'i' || symbol === 'ii' || symbol === 'iii' || symbol === 'vi' || symbol === 'rel. ii') return 'minor';
            return 'major';
        }

        function sortTopNotes(topNotes) {
            return topNotes.sort((a, b) => {
                // Remove ‚ô≠ and ‚ôØ for sorting, just use the base number
                const getBaseNumber = (note) => {
                    const cleaned = note.replace(/[‚ô≠‚ôØ]/g, '');
                    return parseFloat(cleaned) || (cleaned === '‚ôÆ7' ? 7 : 999);
                };
                return getBaseNumber(a) - getBaseNumber(b);
            });
        }

        function getFilteredVoicingData(chordType, chordSymbol) {
            const availableVoicings = voicingData[chordType] || {};
            
            // Filter out specific scales for degree ii
            if (chordSymbol === 'ii') {
                const filtered = { ...availableVoicings };
                if (filtered["Pentatonic ‚ô≠3"]) {
                    delete filtered["Pentatonic ‚ô≠3"];
                }
                if (filtered["Pentatonic ‚ô≠6 (from 5)"]) {
                    delete filtered["Pentatonic ‚ô≠6 (from 5)"];
                }
                return filtered;
            }
            
            return availableVoicings;
        }

        function getFirstVoicing(chordType, chordSymbol = null) {
            const availableVoicings = getFilteredVoicingData(chordType, chordSymbol);
            const scales = Object.keys(availableVoicings);
            if (scales.length === 0) return null;

            // Get all top notes and sort them
            const allTopNotes = getAllTopNotes(chordType, chordSymbol);
            if (allTopNotes.length === 0) return null;

            // Get first top note
            const firstTopNote = allTopNotes[0];
            
            // Get voicings for first top note
            const voicingsForFirstTopNote = getVoicingsForTopNote(chordType, firstTopNote, chordSymbol);
            if (voicingsForFirstTopNote.length === 0) return null;

            // Return first voicing of first top note
            return voicingsForFirstTopNote[0];
        }
        
        function getClosestVoicing(newChordType, previousChord, newChordSymbol = null) {
            // Get the previous chord's actual top note pitch
            const previousChordType = getChordType(previousChord.symbol);
            const previousTopNotePitch = getActualPitchInSemitones(previousChord.currentTopNote, previousChord.symbol, previousChordType);
            
            if (previousTopNotePitch === null) {
                // Fallback to first voicing if we can't calculate previous pitch
                return getFirstVoicing(newChordType);
            }
            
            // Get all available top notes for the new chord
            const allTopNotes = getAllTopNotes(newChordType, newChordSymbol);
            if (allTopNotes.length === 0) return null;
            
            let closestTopNote = null;
            let smallestInterval = Infinity;
            
            // Find the top note with the smallest interval to the previous top note
            allTopNotes.forEach(topNote => {
                // Use the actual new chord symbol for accurate pitch calculation
                const newTopNotePitch = getActualPitchInSemitones(topNote, newChordSymbol, newChordType);
                
                if (newTopNotePitch !== null) {
                    // Calculate interval (allowing for octave equivalence)
                    let interval = newTopNotePitch - previousTopNotePitch;
                    
                    // Normalize to within one octave for analysis
                    while (interval > 6) interval -= 12;
                    while (interval < -6) interval += 12;
                    
                    const absInterval = Math.abs(interval);
                    
                    if (absInterval < smallestInterval) {
                        smallestInterval = absInterval;
                        closestTopNote = topNote;
                    }
                }
            });
            
            if (!closestTopNote) {
                return getFirstVoicing(newChordType);
            }
            
            // Get voicings for the closest top note
            const voicingsForClosestTopNote = getVoicingsForTopNote(newChordType, closestTopNote, newChordSymbol);
            if (voicingsForClosestTopNote.length === 0) {
                return getFirstVoicing(newChordType, newChordSymbol);
            }
            
            // Return first voicing of the closest top note
            return voicingsForClosestTopNote[0];
        }

        function getVoicingsForTopNote(chordType, topNote, chordSymbol = null) {
            const availableVoicings = getFilteredVoicingData(chordType, chordSymbol);
            const voicings = [];
            
            Object.entries(availableVoicings).forEach(([scaleName, scaleVoicings]) => {
                if (scaleVoicings[topNote]) {
                    voicings.push({
                        key: `${scaleName}:${topNote}`,
                        topNote,
                        voicing: scaleVoicings[topNote],
                        scaleName
                    });
                }
            });

            return voicings;
        }

        function getAllTopNotes(chordType, chordSymbol = null) {
            const availableVoicings = getFilteredVoicingData(chordType, chordSymbol);
            const topNotes = new Set();
            
            Object.entries(availableVoicings).forEach(([scaleName, scaleVoicings]) => {
                Object.keys(scaleVoicings).forEach(topNote => topNotes.add(topNote));
            });

            return sortTopNotes([...topNotes]);
        }

        function getAvailableVoicings(chordType) {
            const voicingsByTopNote = {};
            
            // Group voicings by top note
            Object.entries(voicingData[chordType] || {}).forEach(([scaleName, scaleVoicings]) => {
                Object.entries(scaleVoicings).forEach(([topNote, voicing]) => {
                    if (!voicingsByTopNote[topNote]) {
                        voicingsByTopNote[topNote] = [];
                    }
                    
                    // Convert array format to display string - keep it horizontal for dropdown
                    let voicingDisplay;
                    if (Array.isArray(voicing)) {
                        voicingDisplay = voicing.join(' ');
                    } else {
                        voicingDisplay = voicing.replace(/\n/g, ' ');
                    }
                    
                    voicingsByTopNote[topNote].push({
                        key: `${scaleName}:${topNote}`,
                        label: voicingDisplay,
                        voicing: voicing,
                        scaleName: scaleName
                    });
                });
            });
            
            // Sort top notes and flatten the structure for dropdown
            const sortedTopNotes = Object.keys(voicingsByTopNote).sort((a, b) => {
                // Custom sort to handle numbers and symbols properly
                const aNum = parseFloat(a) || (a === '‚ô≠9' ? -0.5 : a === '‚ôØ9' ? 0.5 : a === '‚ôØ11' ? 4.5 : a === '‚ô≠13' ? 5.5 : 999);
                const bNum = parseFloat(b) || (b === '‚ô≠9' ? -0.5 : b === '‚ôØ9' ? 0.5 : b === '‚ôØ11' ? 4.5 : b === '‚ô≠13' ? 5.5 : 999);
                return aNum - bNum;
            });
            
            const result = [];
            sortedTopNotes.forEach(topNote => {
                // Add separator/header for each top note group
                result.push({
                    key: `header-${topNote}`,
                    label: `‚îÄ‚îÄ‚îÄ Top Note: ${topNote} ‚îÄ‚îÄ‚îÄ`,
                    isHeader: true
                });
                
                // Add all voicings for this top note
                voicingsByTopNote[topNote].forEach(voicing => {
                    result.push(voicing);
                });
            });
            
            return result;
        }

        function changeTopNoteFromDropdown(chordId, newTopNote) {
            const chord = currentProgression.find(c => c.id === chordId);
            if (!chord) return;

            const chordType = getChordType(chord.symbol);
            const voicingsForNewTopNote = getVoicingsForTopNote(chordType, newTopNote, chord.symbol);
            
            if (voicingsForNewTopNote.length > 0) {
                // Set to first voicing of the new top note
                chord.currentTopNote = newTopNote;
                chord.currentVoicingIndex = 0;
                updateChordVoicing(chord, voicingsForNewTopNote[0]);
            }

            renderProgression();
        }

        function changeVoicing(chordId, direction) {
            const chord = currentProgression.find(c => c.id === chordId);
            if (!chord) return;

            const chordType = getChordType(chord.symbol);
            const voicingsForCurrentTopNote = getVoicingsForTopNote(chordType, chord.currentTopNote, chord.symbol);
            const newIndex = chord.currentVoicingIndex + direction;

            if (newIndex >= 0 && newIndex < voicingsForCurrentTopNote.length) {
                chord.currentVoicingIndex = newIndex;
                updateChordVoicing(chord, voicingsForCurrentTopNote[newIndex]);
            }

            renderProgression();
        }

        function formatVoicingWithPositions(voicing, topNote) {
            if (!Array.isArray(voicing)) return voicing;
            
            const notes = [];
            voicing.forEach((note, index) => {
                notes.push(note);
                if ((index + 1) % 3 === 0 && index < voicing.length - 1) {
                    notes.push('');
                }
            });
            
            return notes.map((note, index) => {
                if (note === '') return '';
                const isTopNote = index === 0;
                const positionNum = index < 3 ? index + 1 : index;
                return {
                    note,
                    position: positionNum,
                    isTopNote
                };
            });
        }

        function updateChordVoicing(chord, voicingData) {
            // Store both simple and detailed voicing formats
            if (Array.isArray(voicingData.voicing)) {
                // Simple format for voice leading analysis
                const notes = [];
                voicingData.voicing.forEach((note, index) => {
                    notes.push(note);
                    if ((index + 1) % 3 === 0 && index < voicingData.voicing.length - 1) {
                        notes.push('');
                    }
                });
                chord.selectedVoicing = notes.join('\n');
                
                // Detailed format for enhanced display
                chord.voicingWithPositions = formatVoicingWithPositions(voicingData.voicing, voicingData.topNote);
            } else {
                chord.selectedVoicing = voicingData.voicing;
                chord.voicingWithPositions = null;
            }
            chord.selectedVoicingKey = voicingData.key;
            chord.scaleName = voicingData.scaleName;
        }


        // Save/Load Functions
        function saveProgression() {
            if (currentProgression.length === 0) {
                alert('No progression to save. Add some chords first!');
                return;
            }
            
            // Create simplified progression data for export
            const progressionData = {
                version: "1.0",
                created: new Date().toISOString(),
                progression: currentProgression.map(chord => ({
                    symbol: chord.symbol,
                    currentTopNote: chord.currentTopNote,
                    currentVoicingIndex: chord.currentVoicingIndex,
                    selectedVoicingKey: chord.selectedVoicingKey,
                    scaleName: chord.scaleName
                }))
            };
            
            // Create filename with timestamp
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            const filename = `jazz-progression-${timestamp}.json`;
            
            // Download the file
            const blob = new Blob([JSON.stringify(progressionData, null, 2)], {
                type: 'application/json'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function saveProgressionFromLibrary(progressionId, buttonElement) {
            const progressionData = JSON.parse(buttonElement.getAttribute('data-progression'));
            
            // Create the same format as the existing save function
            const exportData = {
                version: "1.0",
                created: new Date().toISOString(),
                progression: []
            };
            
            // Convert the progression library format (V7‚ÜíI) to the standard save format
            // Add V7 chord
            if (progressionData.v7) {
                const v7Chord = progressionData.v7;
                exportData.progression.push({
                    symbol: "V7",
                    currentTopNote: v7Chord.topNote.toString(),
                    currentVoicingIndex: v7Chord.voicingIndex || 0,
                    selectedVoicingKey: `${v7Chord.scaleName}:${v7Chord.topNote}`,
                    scaleName: v7Chord.scaleName
                });
            }
            
            // Add I chord
            if (progressionData.i) {
                const iChord = progressionData.i;
                exportData.progression.push({
                    symbol: "I",
                    currentTopNote: iChord.topNote.toString(),
                    currentVoicingIndex: iChord.voicingIndex || 0,
                    selectedVoicingKey: `${iChord.scaleName}:${iChord.topNote}`,
                    scaleName: iChord.scaleName
                });
            }
            
            // Create filename
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            const filename = `jazz-progression-${timestamp}.json`;
            
            // Download the file
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                type: 'application/json'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function loadProgression() {
            document.getElementById('file-input').click();
        }
        
        function clearProgression() {
            if (currentProgression.length === 0) {
                return; // Nothing to clear
            }
            
            currentProgression = [];
            renderProgression();
        }
        
        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate file format
                    if (!data.progression || !Array.isArray(data.progression)) {
                        throw new Error('Invalid progression file format');
                    }
                    
                    // Clear current progression
                    currentProgression = [];
                    
                    // Reconstruct progression
                    data.progression.forEach(chordData => {
                        const chordType = getChordType(chordData.symbol);
                        
                        // Find the specific voicing that was saved
                        const voicingsForTopNote = getVoicingsForTopNote(chordType, chordData.currentTopNote, chordData.symbol);
                        let selectedVoicing = null;
                        
                        // Try to find exact voicing by key or index
                        if (chordData.selectedVoicingKey) {
                            selectedVoicing = voicingsForTopNote.find(v => v.key === chordData.selectedVoicingKey);
                        }
                        if (!selectedVoicing && chordData.currentVoicingIndex < voicingsForTopNote.length) {
                            selectedVoicing = voicingsForTopNote[chordData.currentVoicingIndex];
                        }
                        if (!selectedVoicing && voicingsForTopNote.length > 0) {
                            selectedVoicing = voicingsForTopNote[0]; // Fallback
                        }
                        
                        if (selectedVoicing) {
                            const newChord = {
                                id: Date.now() + Math.random(), // Ensure unique ID
                                symbol: chordData.symbol,
                                selectedVoicing: null,
                                selectedVoicingKey: chordData.selectedVoicingKey,
                                currentTopNote: chordData.currentTopNote,
                                currentVoicingIndex: chordData.currentVoicingIndex,
                                scaleName: chordData.scaleName,
                                voicingWithPositions: null
                            };
                            
                            updateChordVoicing(newChord, selectedVoicing);
                            currentProgression.push(newChord);
                        }
                    });
                    
                    renderProgression();
                    
                } catch (error) {
                    alert('Error loading progression file: ' + error.message);
                }
                
                // Clear the file input
                event.target.value = '';
            };
            
            reader.readAsText(file);
        }

        // Progressions Library Functions
        function loadProgressionsLibraryMode() {
            loadProgressionType();
        }

        function loadProgressionType() {
            const progressionType = document.getElementById('progression-type').value;
            const content = document.getElementById('progression-library-content');
            
            if (progressionType === 'V7-I') {
                content.innerHTML = generateV7IProgressions();
            }
        }

        // Global variable to store all progressions data
        let allProgressionsData = {};

        function generateV7IProgressions() {
            // Get all V7 (dominant) and I (major) voicing combinations
            const v7Voicings = getAllVoicingCombinations('dominant');
            const iVoicings = getAllVoicingCombinations('major');
            
            
            // Group progressions by top-note-line with direction (relative to tonal center)
            const progressionsByTopNoteLine = {};
            
            v7Voicings.forEach(v7 => {
                iVoicings.forEach(i => {
                    // Calculate top-note-line relative to tonal center
                    const iTonalNote = getTonicRelativeNote(i.topNote, 'I');
                    const v7TonalNote = getTonicRelativeNote(v7.topNote, 'V7', i.topNote);
                    
                    // Skip if we can't map the notes
                    if (!v7TonalNote || !iTonalNote) return;
                    
                    // Skip harmonically invalid combinations
                    // ‚ôØ1 relative to tonic doesn't exist in proper V7-I progressions
                    if (v7TonalNote === '‚ôØ1' || iTonalNote === '‚ôØ1') {
                        return;
                    }
                    
                    // Calculate both upward and downward movements
                    const movements = calculateAllTopNoteMovements(v7TonalNote, iTonalNote);
                    
                    movements.forEach(movement => {
                        // Check if this voicing pair actually moves in the expected direction
                        const actualTopNoteMovement = calculateActualTopNoteMovement(v7.topNote, i.topNote);
                        const expectedUp = movement.direction === '‚Üó';
                        const actualUp = actualTopNoteMovement > 0;
                        
                        
                        // Only add this voicing pair if it matches the expected direction
                        // Be more strict about direction matching
                        const isValidDirection = (expectedUp && actualUp) || 
                                               (!expectedUp && !actualUp);
                        
                        if (isValidDirection) {
                            const topNoteLineWithDirection = `${v7TonalNote}-${iTonalNote} ${movement.direction}`;
                            
                            if (!progressionsByTopNoteLine[topNoteLineWithDirection]) {
                                progressionsByTopNoteLine[topNoteLineWithDirection] = [];
                            }
                            
                            progressionsByTopNoteLine[topNoteLineWithDirection].push({
                                v7: v7,
                                i: i,
                                movement: movement
                            });
                        }
                    });
                });
            });
            
            // Store data globally for filtering
            allProgressionsData = progressionsByTopNoteLine;
            
            
            // Generate navigation list
            generateTopNoteLineNavigation(progressionsByTopNoteLine);
            
            // Return empty string - user must filter first
            return '<div class="empty-state">Select a top-note-line from the left panel to view progressions.</div>';
        }

        function getTopNoteLineDisplayLabel(topNoteLineWithDirection) {
            const [movement, direction] = topNoteLineWithDirection.split(' ');
            let [start, end] = movement.split('-');
            
            // Apply enharmonic corrections for better voice leading logic
            if (start === '‚ô≠6' && end === '6') {
                start = '‚ôØ5'; // ‚ô≠6-6 becomes ‚ôØ5-6
            } else if (start === '‚ôØ6' && end === '6') {
                start = '‚ô≠7'; // ‚ôØ6-6 becomes ‚ô≠7-6
            }
            
            // Check if it's a common tone
            if (start === end && direction === '‚Üí') {
                return `${start}-${end}`;
            }
            
            // For 1 semitone movements, use ‚ôØ/‚ô≠ notation
            const semitoneMap = {
                '1': 0, '‚ô≠2': 1, '2': 2, '‚ôØ2': 3, '‚ô≠3': 3, '3': 4,
                '4': 5, '‚ôØ4': 6, '‚ô≠5': 6, '5': 7, '‚ôØ5': 8, '‚ô≠6': 8,
                '6': 9, '‚ôØ6': 10, '‚ô≠7': 10, '7': 11, '‚ôØ7': 11, '‚ôØ1': 12
            };
            
            const startSemitone = semitoneMap[start] ?? 0;
            const endSemitone = semitoneMap[end] ?? 0;
            const semitoneDistance = Math.abs(endSemitone - startSemitone);
            
            // Temporarily disabled 1-semitone conversion to debug
            // if (semitoneDistance === 1) {
            //     // For 1 semitone movements, use ‚ôØ/‚ô≠ notation
            //     if (direction === '‚Üó') {
            //         // Going up: use ‚ôØ on start note
            //         const sharpStart = start === '1' ? '‚ôØ1' : start === '2' ? '‚ôØ2' : start === '4' ? '‚ôØ4' : start === '5' ? '‚ôØ5' : start === '6' ? '‚ôØ6' : start;
            //         return `${sharpStart}-${end} ${direction}`;
            //     } else if (direction === '‚Üò') {
            //         // Going down: use ‚ô≠ on end note  
            //         const flatEnd = end === '2' ? '‚ô≠2' : end === '3' ? '‚ô≠3' : end === '5' ? '‚ô≠5' : end === '6' ? '‚ô≠6' : end === '7' ? '‚ô≠7' : end;
            //         return `${start}-${flatEnd} ${direction}`;
            //     }
            // }
            
            // For non-common tones, show the movement pattern with "-"
            return `${start}-${end} ${direction}`;
        }

        function getSortMethod() {
            const checkedRadio = document.querySelector('input[name="sort-method"]:checked');
            return checkedRadio ? checkedRadio.value : 'closeness';
        }

        function refreshNavigation() {
            if (allProgressionsData && Object.keys(allProgressionsData).length > 0) {
                generateTopNoteLineNavigation(allProgressionsData);
            }
        }

        function generateTopNoteLineNavigation(progressionsByTopNoteLine) {
            const navList = document.getElementById('top-note-line-list');
            const sortMethod = getSortMethod();
            
            // Sort top-note-lines based on selected method
            const sortedTopNoteLines = Object.keys(progressionsByTopNoteLine).sort((a, b) => {
                if (sortMethod === 'count') {
                    // Sort by number of progressions (descending)
                    const aCount = progressionsByTopNoteLine[a].length;
                    const bCount = progressionsByTopNoteLine[b].length;
                    return bCount - aCount;
                } else {
                    // Sort by interval closeness (current method)
                // Parse top-note-line with direction (e.g., "7-1 ‚Üò" or "2-3 ‚Üó")
                const [aMovement, aDirection] = a.split(' ');
                const [bMovement, bDirection] = b.split(' ');
                const [aStart, aEnd] = aMovement.split('-');
                const [bStart, bEnd] = bMovement.split('-');
                
                // Calculate interval size using semitones for accurate measurement
                const semitoneMap = {
                    '1': 0, '‚ô≠2': 1, '2': 2, '‚ôØ2': 3, '‚ô≠3': 3, '3': 4,
                    '4': 5, '‚ôØ4': 6, '‚ô≠5': 6, '5': 7, '‚ôØ5': 8, '‚ô≠6': 8,
                    '6': 9, '‚ôØ6': 10, '‚ô≠7': 10, '7': 11, '‚ôÆ7': 11, '‚ôØ1': 12
                };
                
                const aStartSemitone = semitoneMap[aStart] ?? 0;
                const aEndSemitone = semitoneMap[aEnd] ?? 0;
                const bStartSemitone = semitoneMap[bStart] ?? 0;
                const bEndSemitone = semitoneMap[bEnd] ?? 0;
                
                // Calculate interval distance - common tones get priority score
                let aInterval, bInterval;
                
                // Check if these are true common tones (same note to same note AND ‚Üí direction)
                const isACommonTone = aStart === aEnd && aDirection === '‚Üí';
                const isBCommonTone = bStart === bEnd && bDirection === '‚Üí';
                
                // Assign interval values - common tones get -1 to sort first
                if (isACommonTone) {
                    aInterval = -1;
                } else {
                    // For upward direction (‚Üó), use the upward distance
                    if (aDirection === '‚Üó') {
                        const directInterval = aEndSemitone - aStartSemitone;
                        aInterval = directInterval >= 0 ? directInterval : directInterval + 12;
                    } 
                    // For downward direction (‚Üò), use the downward distance
                    else if (aDirection === '‚Üò') {
                        const directInterval = aEndSemitone - aStartSemitone;
                        aInterval = directInterval <= 0 ? Math.abs(directInterval) : 12 - directInterval;
                    }
                    // For common tone (‚Üí), interval is 0
                    else {
                        aInterval = 0;
                    }
                }
                
                // Same calculation for b
                if (isBCommonTone) {
                    bInterval = -1;
                } else {
                    if (bDirection === '‚Üó') {
                        const directInterval = bEndSemitone - bStartSemitone;
                        bInterval = directInterval >= 0 ? directInterval : directInterval + 12;
                    } 
                    else if (bDirection === '‚Üò') {
                        const directInterval = bEndSemitone - bStartSemitone;
                        bInterval = directInterval <= 0 ? Math.abs(directInterval) : 12 - directInterval;
                    }
                    else {
                        bInterval = 0;
                    }
                }
                
                // First sort by interval size (smaller intervals first)
                if (aInterval !== bInterval) {
                    return aInterval - bInterval;
                }
                
                // Then sort alphabetically by the movement part (without direction and accidentals)
                if (aMovement !== bMovement) {
                    // Remove accidentals for comparison (‚ô≠, ‚ôØ, ‚ôÆ)
                    const normalizeForSort = (movement) => {
                        return movement.replace(/[‚ô≠‚ôØ‚ôÆ]/g, '');
                    };
                    const aNormalized = normalizeForSort(aMovement);
                    const bNormalized = normalizeForSort(bMovement);
                    
                    if (aNormalized !== bNormalized) {
                        return aNormalized.localeCompare(bNormalized);
                    }
                    
                    // If base movement is same, sort by actual movement (with accidentals)
                    return aMovement.localeCompare(bMovement);
                }
                
                // Finally sort by direction (‚Üó before ‚Üò before ‚Üí)
                const directionOrder = { '‚Üó': 1, '‚Üí': 2, '‚Üò': 3 };
                return (directionOrder[aDirection] || 4) - (directionOrder[bDirection] || 4);
                }
            });
            
            let navHTML = '';
            sortedTopNoteLines.forEach(topNoteLineWithDirection => {
                const progressions = progressionsByTopNoteLine[topNoteLineWithDirection];
                const count = progressions.length;
                
                // Extract the movement info for display
                const sampleProgression = progressions[0];
                const movement = sampleProgression.movement;
                
                // Create a cleaner display label
                const displayLabel = getTopNoteLineDisplayLabel(topNoteLineWithDirection);
                
                navHTML += `
                    <div class="top-note-line-item" onclick="filterByTopNoteLine('${topNoteLineWithDirection}')">
                        <span class="top-note-line-name">${displayLabel}</span>
                        <span class="top-note-line-count">${count}</span>
                    </div>
                `;
            });
            
            navList.innerHTML = navHTML;
        }

        function generateProgressionsHTML(progressionsByTopNoteLine, selectedTopNoteLine = null) {
            // Sort top-note-lines by interval closeness, then alphabetically (same as navigation)
            const sortedTopNoteLines = Object.keys(progressionsByTopNoteLine).sort((a, b) => {
                // Parse top-note-line with direction (e.g., "7-1 ‚Üò" or "2-3 ‚Üó")
                const [aMovement, aDirection] = a.split(' ');
                const [bMovement, bDirection] = b.split(' ');
                const [aStart, aEnd] = aMovement.split('-');
                const [bStart, bEnd] = bMovement.split('-');
                
                // Calculate interval size using semitones for accurate measurement
                const semitoneMap = {
                    '1': 0, '‚ô≠2': 1, '2': 2, '‚ôØ2': 3, '‚ô≠3': 3, '3': 4,
                    '4': 5, '‚ôØ4': 6, '‚ô≠5': 6, '5': 7, '‚ôØ5': 8, '‚ô≠6': 8,
                    '6': 9, '‚ôØ6': 10, '‚ô≠7': 10, '7': 11, '‚ôÆ7': 11, '‚ôØ1': 12
                };
                
                const aStartSemitone = semitoneMap[aStart] ?? 0;
                const aEndSemitone = semitoneMap[aEnd] ?? 0;
                const bStartSemitone = semitoneMap[bStart] ?? 0;
                const bEndSemitone = semitoneMap[bEnd] ?? 0;
                
                // Calculate interval distance - common tones get priority score
                let aInterval, bInterval;
                
                // Check if these are true common tones (same note to same note AND ‚Üí direction)
                const isACommonTone = aStart === aEnd && aDirection === '‚Üí';
                const isBCommonTone = bStart === bEnd && bDirection === '‚Üí';
                
                // Assign interval values - common tones get -1 to sort first
                if (isACommonTone) {
                    aInterval = -1;
                } else {
                    // For upward direction (‚Üó), use the upward distance
                    if (aDirection === '‚Üó') {
                        const directInterval = aEndSemitone - aStartSemitone;
                        aInterval = directInterval >= 0 ? directInterval : directInterval + 12;
                    } 
                    // For downward direction (‚Üò), use the downward distance
                    else if (aDirection === '‚Üò') {
                        const directInterval = aEndSemitone - aStartSemitone;
                        aInterval = directInterval <= 0 ? Math.abs(directInterval) : 12 - directInterval;
                    }
                    // For common tone (‚Üí), interval is 0
                    else {
                        aInterval = 0;
                    }
                }
                
                // Same calculation for b
                if (isBCommonTone) {
                    bInterval = -1;
                } else {
                    if (bDirection === '‚Üó') {
                        const directInterval = bEndSemitone - bStartSemitone;
                        bInterval = directInterval >= 0 ? directInterval : directInterval + 12;
                    } 
                    else if (bDirection === '‚Üò') {
                        const directInterval = bEndSemitone - bStartSemitone;
                        bInterval = directInterval <= 0 ? Math.abs(directInterval) : 12 - directInterval;
                    }
                    else {
                        bInterval = 0;
                    }
                }
                
                // First sort by interval size (smaller intervals first)
                if (aInterval !== bInterval) {
                    return aInterval - bInterval;
                }
                
                // Then sort alphabetically by the movement part (without direction and accidentals)
                if (aMovement !== bMovement) {
                    // Remove accidentals for comparison (‚ô≠, ‚ôØ, ‚ôÆ)
                    const normalizeForSort = (movement) => {
                        return movement.replace(/[‚ô≠‚ôØ‚ôÆ]/g, '');
                    };
                    const aNormalized = normalizeForSort(aMovement);
                    const bNormalized = normalizeForSort(bMovement);
                    
                    if (aNormalized !== bNormalized) {
                        return aNormalized.localeCompare(bNormalized);
                    }
                    
                    // If base movement is same, sort by actual movement (with accidentals)
                    return aMovement.localeCompare(bMovement);
                }
                
                // Finally sort by direction (‚Üó before ‚Üò before ‚Üí)
                const directionOrder = { '‚Üó': 1, '‚Üí': 2, '‚Üò': 3 };
                return (directionOrder[aDirection] || 4) - (directionOrder[bDirection] || 4);
            });
            
            let html = '';
            const linesToShow = selectedTopNoteLine ? [selectedTopNoteLine] : sortedTopNoteLines;
            
            linesToShow.forEach(topNoteLineWithDirection => {
                const progressions = progressionsByTopNoteLine[topNoteLineWithDirection];
                if (progressions) {
                    html += generateTopNoteLineSection(topNoteLineWithDirection, progressions);
                }
            });
            
            return html;
        }

        function filterByTopNoteLine(topNoteLine) {
            // Update navigation active state
            document.querySelectorAll('.top-note-line-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Set active item
            event.target.closest('.top-note-line-item').classList.add('active');
            
            // Update title with clean display label
            const displayLabel = getTopNoteLineDisplayLabel(topNoteLine);
            document.getElementById('current-filter-title').textContent = `Top-Note-Line: ${displayLabel}`;
            
            // Filter and display progressions
            const filteredData = { [topNoteLine]: allProgressionsData[topNoteLine] };
            const html = generateProgressionsHTML(filteredData, topNoteLine);
            document.getElementById('progression-library-content').innerHTML = html;
        }

        function normalizeSearchTerm(term) {
            // Normalize common symbol variations for flexible search
            return term
                .replace(/b/g, '‚ô≠')      // b -> ‚ô≠
                .replace(/#/g, '‚ôØ')      // # -> ‚ôØ
                .replace(/n/g, '‚ôÆ');     // n -> ‚ôÆ
        }

        function filterTopNoteLines() {
            const searchInput = document.getElementById('search-input');
            const rawSearchTerm = searchInput.value.toLowerCase().trim();
            const searchTerm = normalizeSearchTerm(rawSearchTerm);
            const navItems = document.querySelectorAll('.top-note-line-item');
            
            navItems.forEach(item => {
                const displayText = item.textContent.toLowerCase();
                
                let shouldShow = false;
                
                if (rawSearchTerm === '') {
                    shouldShow = true;
                } else {
                    // Check if display text contains the search term
                    shouldShow = displayText.includes(searchTerm);
                }
                
                item.style.display = shouldShow ? 'block' : 'none';
            });
        }


        function getAllVoicingCombinations(chordType) {
            const combinations = [];
            const chordTypeData = voicingData[chordType] || {};
            
            Object.entries(chordTypeData).forEach(([scaleName, scaleVoicings]) => {
                Object.entries(scaleVoicings).forEach(([topNote, voicing]) => {
                    combinations.push({
                        scaleName,
                        topNote,
                        voicing,
                        chordType
                    });
                });
            });
            
            return combinations;
        }

        function getTonicRelativeNote(topNote, chordFunction, resolvesToNote = null) {
            // Convert chord-relative top note to tonic-relative scale degree
            const chordTonicMapping = {
                'V7': {
                    '1': '5', '3': '7', '5': '2', '7': '4', 
                    '‚ô≠9': '‚ô≠6', '9': '6', '‚ôØ9': '‚ôØ6', 
                    '‚ôØ11': '‚ô≠2', '‚ô≠13': '‚ô≠3', '13': '3'
                },
                'I': {
                    '1': '1', '‚ô≠2': '‚ô≠2', '2': '2', '‚ôØ2': '‚ôØ2', '3': '3', '5': '5', '7': '7',
                    '9': '2', '‚ôØ11': '‚ôØ4', '13': '6'
                }
            };
            
            let result = chordTonicMapping[chordFunction][topNote];
            
            // Special case: V7 ‚ô≠13 maps to ‚ôØ2 only when resolving to I 3, otherwise ‚ô≠3
            if (chordFunction === 'V7' && topNote === '‚ô≠13' && resolvesToNote) {
                const iTonicNote = chordTonicMapping['I'][resolvesToNote];
                result = (iTonicNote === '3') ? '‚ôØ2' : '‚ô≠3';
            }
            
            return result || null;
        }

        function getScaleNumber(note) {
            const noteValues = {
                '1': 1, '‚ô≠2': 1.5, '2': 2, '‚ôØ2': 2.5, '‚ô≠3': 3, '3': 3.5,
                '4': 4, '‚ôØ4': 4.5, '‚ô≠5': 4.5, '5': 5, '‚ôØ5': 5.5, '‚ô≠6': 6,
                '6': 6.5, '‚ôØ6': 6.5, '‚ô≠7': 7, '7': 7.5, '‚ôØ7': 7.5
            };
            return noteValues[note] || 8;
        }

        function calculateActualTopNoteMovement(v7TopNote, iTopNote) {
            // Calculate the actual semitone movement between voicing top notes
            // But we need to consider the harmonic context: V7 vs I chord
            const semitoneMap = {
                '1': 0, '‚ô≠2': 1, '2': 2, '‚ôØ2': 3, '‚ô≠3': 3, '3': 4,
                '4': 5, '‚ôØ4': 6, '‚ô≠5': 6, '5': 7, '‚ôØ5': 8, '‚ô≠6': 8,
                '6': 9, '‚ôØ6': 10, '‚ô≠7': 10, '7': 11, '‚ôØ7': 11,
                '‚ô≠9': 1, '9': 2, '‚ôØ9': 3, '‚ôØ11': 6, '‚ô≠13': 8, '13': 9
            };
            
            // Get semitone values relative to their chord context
            const v7Semitone = semitoneMap[v7TopNote] ?? 0;
            const iSemitone = semitoneMap[iTopNote] ?? 0;
            
            // For V7-I progressions, we need to account for the chord root movement (V7 is 7 semitones above I)
            // V7 notes are effectively 7 semitones higher in the harmonic context
            const v7AdjustedSemitone = (v7Semitone + 7) % 12;
            
            // Calculate direct interval (allowing negative for downward movement)
            let interval = iSemitone - v7AdjustedSemitone;
            
            // Normalize to within one octave for analysis
            while (interval > 6) interval -= 12;
            while (interval < -6) interval += 12;
            
            return interval;
        }

        function calculateAllTopNoteMovements(fromNote, toNote) {
            // Convert scale degrees to semitones (C major scale reference)
            const semitoneMap = {
                '1': 0, '‚ô≠2': 1, '2': 2, '‚ôØ2': 3, '‚ô≠3': 3, '3': 4,
                '4': 5, '‚ôØ4': 6, '‚ô≠5': 6, '5': 7, '‚ôØ5': 8, '‚ô≠6': 8,
                '6': 9, '‚ôØ6': 10, '‚ô≠7': 10, '7': 11, '‚ôØ7': 11
            };
            
            const fromSemitone = semitoneMap[fromNote];
            const toSemitone = semitoneMap[toNote];
            
            if (fromSemitone === undefined || toSemitone === undefined) {
                return [{ interval: 0, direction: '‚Üí', type: 'common tone', description: 'Unknown movement', semitones: 0 }];
            }
            
            // Calculate direct interval
            const directInterval = toSemitone - fromSemitone;
            
            // Handle common tone
            if (directInterval === 0) {
                return [{
                    interval: 0,
                    direction: '‚Üí',
                    type: 'common tone',
                    description: 'Common tone',
                    semitones: 0
                }];
            }
            
            // Calculate both upward and downward possibilities
            const upwardInterval = directInterval >= 0 ? directInterval : directInterval + 12;
            const downwardInterval = directInterval <= 0 ? directInterval : directInterval - 12;
            
            const movements = [];
            
            // Add upward movement
            if (upwardInterval > 0 && upwardInterval <= 12) {
                const type = upwardInterval <= 2 ? 'step' : 'leap';
                movements.push({
                    interval: upwardInterval,
                    direction: '‚Üó',
                    type: type,
                    description: `${upwardInterval} semitone${upwardInterval > 1 ? 's' : ''} up`,
                    semitones: upwardInterval
                });
            }
            
            // Add downward movement
            if (downwardInterval < 0 && Math.abs(downwardInterval) <= 12) {
                const semitones = Math.abs(downwardInterval);
                const type = semitones <= 2 ? 'step' : 'leap';
                movements.push({
                    interval: downwardInterval,
                    direction: '‚Üò',
                    type: type,
                    description: `${semitones} semitone${semitones > 1 ? 's' : ''} down`,
                    semitones: semitones
                });
            }
            
            return movements;
        }

        function generateTopNoteLineSection(topNoteLineWithDirection, progressions) {
            // Extract movement info from the first progression
            const sampleProgression = progressions[0];
            const movement = sampleProgression.movement;
            
            // Use the same clean display label as in navigation
            const displayLabel = getTopNoteLineDisplayLabel(topNoteLineWithDirection);
            
            let html = `
                <div class="top-note-line-group">
                    <div class="top-note-line-header">
                        <div class="top-note-line-title">${displayLabel}</div>
                    </div>
                    <div class="progression-variations">
            `;
            
            // Sort progressions by total semitone amount (ascending)
            const sortedProgressions = progressions.sort((a, b) => {
                // Calculate total semitones for progression A
                const aAnalysis = analyzeVoiceLeadingDirect(a.v7.voicing, a.i.voicing);
                let aTotalSemitones = 0;
                aAnalysis.forEach(movement => {
                    const semitones = movement.semitones || movement.interval || Math.abs(movement.semitoneDistance || 0);
                    aTotalSemitones += Math.abs(semitones);
                });
                
                // Calculate total semitones for progression B  
                const bAnalysis = analyzeVoiceLeadingDirect(b.v7.voicing, b.i.voicing);
                let bTotalSemitones = 0;
                bAnalysis.forEach(movement => {
                    const semitones = movement.semitones || movement.interval || Math.abs(movement.semitoneDistance || 0);
                    bTotalSemitones += Math.abs(semitones);
                });
                
                return aTotalSemitones - bTotalSemitones;
            });
            
            sortedProgressions.forEach(progression => {
                html += generateProgressionVariation(progression);
            });
            
            html += `
                    </div>
                </div>
            `;
            
            return html;
        }

        function getMovementDescription(startNote, endNote) {
            const startNum = getScaleNumber(startNote);
            const endNum = getScaleNumber(endNote);
            const interval = endNum - startNum;
            
            if (interval === 0) return 'Common tone';
            if (Math.abs(interval) <= 1) return 'Step motion';
            if (interval > 0) return `Up ${Math.abs(interval)} scale degrees`;
            return `Down ${Math.abs(interval)} scale degrees`;
        }

        function formatVoicingForDisplay(voicing) {
            if (!Array.isArray(voicing)) return voicing;
            
            // Display notes vertically - each note on its own line
            // This represents the actual piano hand position from top to bottom
            return voicing.map(note => note || '').join('\n');
        }

        function generateVoiceLeadingLines(analysis) {
            if (!analysis || !analysis.movements) return '';
            
            return analysis.movements.map((movement, index) => {
                const colorClass = movement.type === 'common' ? 'common-tone' : 
                                  movement.type === 'step' ? 'step-motion' : 'leap-motion';
                return `<div class="voice-line ${colorClass}" style="top: ${index * 20 + 10}px;"></div>`;
            }).join('');
        }

        function generateMovementSummary(analysis) {
            if (!analysis || !analysis.movements) return '';
            
            const commonTones = analysis.movements.filter(m => m.type === 'common').length;
            const steps = analysis.movements.filter(m => m.type === 'step').length;
            const leaps = analysis.movements.filter(m => m.type === 'leap').length;
            
            // Calculate total semitones
            const totalSemitones = analysis.movements.reduce((sum, m) => {
                return sum + (m.semitones || m.absInterval || 0);
            }, 0);
            
            return `
                <div class="movement-counts">
                    ${totalSemitones > 0 ? `<span class="count total-semitones">${totalSemitones}S</span>` : ''}
                    ${leaps > 0 ? `<span class="count leap-motion">${leaps}L</span>` : ''}
                </div>
            `;
        }

        function analyzeVoiceLeadingDirect(voicing1, voicing2, expectedMovement = null) {
            const movements = [];
            
            // Analyze each voice position including gaps
            for (let i = 0; i < Math.max(voicing1.length, voicing2.length); i++) {
                const note1 = voicing1[i];
                const note2 = voicing2[i];
                
                // Only analyze if both notes exist and are not empty
                if (note1 && note2 && note1.trim() !== '' && note2.trim() !== '') {
                    const movement = calculateVoiceMovementWithDirection(note1, note2, expectedMovement);
                    movements.push({
                        position: i,
                        from: note1,
                        to: note2,
                        ...movement
                    });
                }
            }
            
            return movements;
        }

        function calculateVoiceMovementWithDirection(note1, note2, expectedMovement) {
            // Get basic movement first
            const baseMovement = calculateVoiceMovement(note1, note2, 'V7', 'dominant', 'I', 'major');
            
            // If no expected movement provided, or it's a common tone, return as-is
            if (!expectedMovement || note1 === note2 || baseMovement.interval === 0) {
                return baseMovement;
            }
            
            // Special cases for classic voice-leading resolutions
            // Leading tone resolution (V7 7th ‚Üí I 3rd)
            if (note1 === '7' && note2 === '3') {
                return {
                    interval: -1,
                    direction: 'down',
                    type: 'step',
                    symbol: '‚Üì¬Ω',
                    semitones: 1,
                    absInterval: 1
                };
            }
            
            // ‚ô≠13 resolution (V7 ‚ô≠13 ‚Üí I 9)
            if (note1 === '‚ô≠13' && note2 === '9') {
                return {
                    interval: -1,
                    direction: 'down',
                    type: 'step',
                    symbol: '‚Üì¬Ω',
                    semitones: 1,
                    absInterval: 1
                };
            }
            
            // ‚ôØ9 resolution (V7 ‚ôØ9 ‚Üí I 13)
            if (note1 === '‚ôØ9' && note2 === '13') {
                return {
                    interval: -1,
                    direction: 'down',
                    type: 'step',
                    symbol: '‚Üì¬Ω',
                    semitones: 1,
                    absInterval: 1
                };
            }
            
            // Apply directional context for interval display
            const expectedUp = expectedMovement.direction === '‚Üó';
            const expectedDown = expectedMovement.direction === '‚Üò';
            const actualInterval = baseMovement.interval;
            const actualUp = actualInterval > 0;
            const actualDown = actualInterval < 0;
            
            
            // If the actual movement direction contradicts the expected direction,
            // apply octave correction for better harmonic representation
            if (((expectedUp && actualDown) || (expectedDown && actualUp))) {
                
                // Apply octave displacement correction
                // If expected upward but actual downward: add 12 to make it upward
                // If expected downward but actual upward: subtract 12 to make it downward
                const correctedInterval = expectedUp ? 
                    (actualInterval + 12) : (actualInterval - 12);
                
                const correctedAbs = Math.abs(correctedInterval);
                const correctedDirection = correctedInterval === 0 ? 'same' : correctedInterval > 0 ? 'up' : 'down';
                
                
                let correctedType, correctedSymbol;
                if (correctedInterval === 0) {
                    correctedType = 'common';
                    correctedSymbol = '=';
                } else if (correctedAbs <= 2) {
                    correctedType = 'step';
                    if (correctedAbs === 1) {
                        correctedSymbol = correctedDirection === 'up' ? '‚Üë¬Ω' : '‚Üì¬Ω';
                    } else {
                        correctedSymbol = correctedDirection === 'up' ? '‚Üë1' : '‚Üì1';
                    }
                } else {
                    correctedType = 'leap';
                    const semitoneCount = correctedAbs % 2 === 0 ? correctedAbs / 2 : `${Math.floor(correctedAbs / 2)}¬Ω`;
                    correctedSymbol = correctedDirection === 'up' ? `‚Üë${semitoneCount}` : `‚Üì${semitoneCount}`;
                }
                
                return {
                    interval: correctedInterval,
                    direction: correctedDirection,
                    type: correctedType,
                    symbol: correctedSymbol,
                    semitones: correctedAbs,
                    absInterval: correctedAbs
                };
            }
            
            // Otherwise return the original calculation
            return baseMovement;
        }

        function generateLibraryVoiceLeadingConnector(fromChord, toChord, expectedMovement) {
            // Analyze voice leading directly with the voicing arrays, considering expected direction
            const movements = analyzeVoiceLeadingDirect(fromChord.voicing, toChord.voicing, expectedMovement);
            
            if (!movements || movements.length === 0) {
                return '<div class="empty-connector">No voice leading data</div>';
            }
            
            const summary = getVoiceLeadingSummary(movements);
            const movementHtml = [];
            
            // Create movement indicators based on the first chord's voicing structure
            if (fromChord.voicing) {
                fromChord.voicing.forEach((note, index) => {
                    if (!note || note.trim() === '') {
                        // Empty gap - add spacing, no movement indicator needed
                        movementHtml.push('<div style="height: 0.5rem;"></div>');
                    } else {
                        // Check if the corresponding position in the second chord is also a gap
                        const toNote = toChord.voicing[index];
                        if (!toNote || toNote.trim() === '') {
                            // Voice disappears - still add spacing
                            movementHtml.push('<div style="height: 0.5rem;"></div>');
                        } else {
                            // Find movement for this voice position
                            const movement = movements.find(m => m.position === index);
                            
                            if (movement) {
                                movementHtml.push(`<div class="voice-movement ${movement.type}" title="Voice ${movement.position + 1}: ${movement.from} ‚Üí ${movement.to}">${movement.symbol}</div>`);
                            } else {
                                // If we have notes in both positions but no movement found, something's wrong
                                // Show a faded indicator but this shouldn't happen
                                movementHtml.push(`<div class="voice-movement" style="opacity: 0.3; background: rgba(255,255,255,0.1);">?</div>`);
                            }
                        }
                    }
                });
            } else {
                // Fallback: create indicators based on movements only
                movements.forEach(movement => {
                    movementHtml.push(`<div class="voice-movement ${movement.type}" title="Voice ${movement.position + 1}: ${movement.from} ‚Üí ${movement.to}">${movement.symbol}</div>`);
                });
            }
            
            return `
                <div class="connector-indicators" title="${summary}">
                    ${movementHtml.join('')}
                </div>
                <div class="movement-summary">
                    ${generateMovementSummary({movements: movements})}
                </div>
            `;
        }

        function formatVoicingForAnalysis(voicing) {
            if (!Array.isArray(voicing)) return voicing;
            
            // Convert array to newline-separated string format that analyzeVoiceLeading expects
            const notes = [];
            voicing.forEach((note, index) => {
                notes.push(note);
                // Add gaps after every 3 notes (similar to updateChordVoicing)
                if ((index + 1) % 3 === 0 && index < voicing.length - 1) {
                    notes.push('');
                }
            });
            return notes.join('\n');
        }

        function generateProgressionVariation(progression) {
            // Format voicings for display
            const v7VoicingFormatted = formatVoicingForDisplay(progression.v7.voicing);
            const iVoicingFormatted = formatVoicingForDisplay(progression.i.voicing);
            
            // Get voice leading analysis
            const voiceLeadingAnalysis = analyzeVoiceLeading(progression.v7.voicing, progression.i.voicing);
            
            // Create unique ID for this progression variation
            const progressionId = `v7-${progression.v7.scaleName.replace(/[^a-zA-Z0-9]/g, '')}-${progression.v7.topNote}-i-${progression.i.scaleName.replace(/[^a-zA-Z0-9]/g, '')}-${progression.i.topNote}`;
            
            return `
                <div class="progression-variation">
                    <div class="library-progression-display">
                        <div class="library-chord">
                            <div class="chord-header">
                                <span class="chord-symbol">V7</span>
                            </div>
                            <div class="voicing-display">
                                <div class="voicing-content">${v7VoicingFormatted}</div>
                                <div class="scale-indicator">${progression.v7.scaleName}</div>
                            </div>
                        </div>
                        
                        <div class="voice-leading-connector library">
                            ${generateLibraryVoiceLeadingConnector(progression.v7, progression.i, progression.movement)}
                        </div>
                        
                        <div class="library-chord">
                            <div class="chord-header">
                                <span class="chord-symbol">I</span>
                            </div>
                            <div class="voicing-display">
                                <div class="voicing-content">${iVoicingFormatted}</div>
                                <div class="scale-indicator">${progression.i.scaleName}</div>
                            </div>
                        </div>
                    </div>
                    <div class="progression-actions">
                        <button class="save-progression-btn" onclick="saveProgressionFromLibrary('${progressionId}', this)" data-progression='${JSON.stringify(progression)}'>
                            Save Progression
                        </button>
                    </div>
                </div>
            `;
        }

        // Initialize the app
        switchMode('progressions-library');
    </script>
</body>
</html>